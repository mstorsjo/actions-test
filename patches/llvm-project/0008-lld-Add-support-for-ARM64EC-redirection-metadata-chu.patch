From d7082fc4d09f17a6a03f7dbd14c9119daadf34f1 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Fri, 24 Feb 2023 01:08:15 +0100
Subject: [PATCH 08/56] [lld] Add support for ARM64EC redirection metadata
 chunk.

---
 lld/COFF/Chunks.cpp                         | 15 +++++
 lld/COFF/Chunks.h                           | 10 ++++
 lld/COFF/Driver.cpp                         |  3 +-
 lld/COFF/SymbolTable.cpp                    |  1 -
 lld/COFF/Writer.cpp                         | 39 ++++++++++++-
 lld/test/COFF/Inputs/loadconfig-arm64ec.s   |  4 +-
 lld/test/COFF/arm64ec-cust-export-thunk.s   | 63 +++++++++++++++++++++
 lld/test/COFF/arm64ec-export-thunks.test    |  9 +++
 lld/test/COFF/arm64ec-exports.s             |  4 +-
 lld/test/COFF/arm64ec-patchable-thunks.test |  4 ++
 10 files changed, 143 insertions(+), 9 deletions(-)
 create mode 100644 lld/test/COFF/arm64ec-cust-export-thunk.s

diff --git a/lld/COFF/Chunks.cpp b/lld/COFF/Chunks.cpp
index 1807e6f4ab7f..e11733a54c10 100644
--- a/lld/COFF/Chunks.cpp
+++ b/lld/COFF/Chunks.cpp
@@ -1078,4 +1078,19 @@ void ECThunkChunk::writeTo(uint8_t *buf) const {
   write32le(buf + 10, target->getRVA() - rva - 14);
 }
 
+size_t ECEntryPointsChunk::getSize() const {
+  return ctx.ECThunks.size() * sizeof(chpe_redirection_entry);
+}
+
+void ECEntryPointsChunk::writeTo(uint8_t *buf) const {
+  auto entries = reinterpret_cast<chpe_redirection_entry *>(buf);
+
+  for (uint32_t i = 0; i < ctx.ECThunks.size(); i++) {
+    Chunk *thunk = ctx.ECThunks[i].first;
+    Defined *target = ctx.ECThunks[i].second;
+    entries[i].Source = thunk->getRVA();
+    entries[i].Destination = target->getRVA();
+  }
+}
+
 } // namespace lld::coff
diff --git a/lld/COFF/Chunks.h b/lld/COFF/Chunks.h
index 192ddabc0129..c615b310e0c7 100644
--- a/lld/COFF/Chunks.h
+++ b/lld/COFF/Chunks.h
@@ -749,6 +749,16 @@ private:
   std::vector<ECCodeMapEntry> &map;
 };
 
+class ECEntryPointsChunk : public NonSectionChunk {
+public:
+  ECEntryPointsChunk(COFFLinkerContext &ctx) : ctx(ctx) {}
+  size_t getSize() const override;
+  void writeTo(uint8_t *buf) const override;
+
+private:
+  COFFLinkerContext &ctx;
+};
+
 static const uint8_t ecThunkCode[] = {
     0x48, 0x8b, 0xc4,          // movq    %rsp, %rax
     0x48, 0x89, 0x58, 0x20,    // movq    %rbx, 0x20(%rax)
diff --git a/lld/COFF/Driver.cpp b/lld/COFF/Driver.cpp
index 5b8661422045..9ae5691fc4c6 100644
--- a/lld/COFF/Driver.cpp
+++ b/lld/COFF/Driver.cpp
@@ -1341,7 +1341,6 @@ void LinkerDriver::maybeMakeECThunk(StringRef name, Symbol *&sym) {
   if (auto undef = dyn_cast<Undefined>(sym)) {
     if (!undef->weakAlias) {
       auto thunk = make<ECThunkChunk>(ctx, def);
-      ctx.ECThunks.push_back({thunk, def});
       replaceSymbol<DefinedSynthetic>(undef, undef->getName(), thunk);
     }
   }
@@ -2404,6 +2403,8 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   if (isArm64EC(config->machine)) {
     ctx.symtab.addAbsolute("__arm64x_extra_rfe_table", 0);
     ctx.symtab.addAbsolute("__arm64x_extra_rfe_table_size", 0);
+    ctx.symtab.addAbsolute("__arm64x_redirection_metadata", 0);
+    ctx.symtab.addAbsolute("__arm64x_redirection_metadata_count", 0);
     ctx.symtab.addAbsolute("__hybrid_code_map", 0);
     ctx.symtab.addAbsolute("__hybrid_code_map_count", 0);
   }
diff --git a/lld/COFF/SymbolTable.cpp b/lld/COFF/SymbolTable.cpp
index 8e5f1c782030..4c83770e0241 100644
--- a/lld/COFF/SymbolTable.cpp
+++ b/lld/COFF/SymbolTable.cpp
@@ -501,7 +501,6 @@ void SymbolTable::resolveRemainingUndefines() {
       }
 
       auto thunk = make<ECThunkChunk>(ctx, cast<DefinedRegular>(targetSym));
-      ctx.ECThunks.push_back({thunk, thunk->target});
       replaceSymbol<DefinedSynthetic>(undef, name, thunk);
     }
   }
diff --git a/lld/COFF/Writer.cpp b/lld/COFF/Writer.cpp
index b81eac082fde..09536fcc2750 100644
--- a/lld/COFF/Writer.cpp
+++ b/lld/COFF/Writer.cpp
@@ -2048,16 +2048,40 @@ void Writer::maybeAddRVATable(SymbolRVASet tableSymbols, StringRef tableSym,
 
 // Create CHPE metadata chunks.
 void Writer::createECChunks() {
-  for (auto it : ctx.ECThunks) {
-    if (auto thunk = dyn_cast<ECThunkChunk>(it.first))
+  ctx.symtab.forEachSymbol([&](Symbol *s) {
+    auto sym = dyn_cast<Defined>(s);
+    if (!sym || !sym->getName().starts_with("EXP+"))
+      return;
+    if (sym->getChunk()->getMachine() != AMD64)
+      return;
+    if (auto thunk = dyn_cast<ECThunkChunk>(sym->getChunk())) {
       hexpthkSec->addChunk(thunk);
-  }
+      ctx.ECThunks.push_back({thunk, thunk->target});
+    } else if (auto def = dyn_cast<DefinedRegular>(sym)) {
+      if (def->getValue() || !def->getChunk()->isCOMDAT()) {
+        warn(def->getName() + " is not a COMDAT symbol");
+        return;
+      }
+      Defined *t = dyn_cast_or_null<Defined>(ctx.symtab.find(
+          toString(sym->getName().substr(strlen("EXP+")) + "$hp_target")));
+      if (!t || !isArm64EC(t->getChunk()->getMachine()))
+        return;
+      ctx.ECThunks.push_back({sym->getChunk(), t});
+    }
+  });
 
   auto codeMapChunk = make<ECCodeMapChunk>(codeMap);
   rdataSec->addChunk(codeMapChunk);
   Symbol *codeMapSym = ctx.symtab.findUnderscore("__hybrid_code_map");
   replaceSymbol<DefinedSynthetic>(codeMapSym, codeMapSym->getName(),
                                   codeMapChunk);
+
+  ECEntryPointsChunk *entryPoints = make<ECEntryPointsChunk>(ctx);
+  rdataSec->addChunk(entryPoints);
+  Symbol *entryPointsSym =
+      ctx.symtab.findUnderscore("__arm64x_redirection_metadata");
+  replaceSymbol<DefinedSynthetic>(entryPointsSym, entryPointsSym->getName(),
+                                  entryPoints);
 }
 
 // MinGW specific. Gather all relocations that are imported from a DLL even
@@ -2150,6 +2174,11 @@ void Writer::setECSymbols() {
   if (!isArm64EC(ctx.config.machine))
     return;
 
+  llvm::stable_sort(ctx.ECThunks, [](const std::pair<Chunk *, Defined *> &a,
+                                     const std::pair<Chunk *, Defined *> &b) {
+    return a.first->getRVA() < b.first->getRVA();
+  });
+
   Symbol *rfeTableSym = ctx.symtab.findUnderscore("__arm64x_extra_rfe_table");
   replaceSymbol<DefinedSynthetic>(rfeTableSym, "__arm64x_extra_rfe_table",
                                   pdata.first);
@@ -2161,6 +2190,10 @@ void Writer::setECSymbols() {
         ->setVA(pdata.last->getRVA() + pdata.last->getSize() -
                 pdata.first->getRVA());
   }
+
+  Symbol *entryPointCountSym =
+      ctx.symtab.findUnderscore("__arm64x_redirection_metadata_count");
+  cast<DefinedAbsolute>(entryPointCountSym)->setVA(ctx.ECThunks.size());
 }
 
 // Write section contents to a mmap'ed file.
diff --git a/lld/test/COFF/Inputs/loadconfig-arm64ec.s b/lld/test/COFF/Inputs/loadconfig-arm64ec.s
index a270d281095d..62a6d0cab642 100644
--- a/lld/test/COFF/Inputs/loadconfig-arm64ec.s
+++ b/lld/test/COFF/Inputs/loadconfig-arm64ec.s
@@ -67,7 +67,7 @@ __chpe_metadata:
         .rva __hybrid_code_map
         .word __hybrid_code_map_count
         .word 0 // __x64_code_ranges_to_entry_points
-        .word 0 //__arm64x_redirection_metadata
+        .rva __arm64x_redirection_metadata
         .rva __os_arm64x_dispatch_call_no_redirect
         .rva __os_arm64x_dispatch_ret
         .rva __os_arm64x_check_call
@@ -76,7 +76,7 @@ __chpe_metadata:
         .word 0 // __arm64x_native_entrypoint
         .word 0 // __hybrid_auxiliary_iat
         .word 0 // __x64_code_ranges_to_entry_points_count
-        .word 0 // __arm64x_redirection_metadata_count
+        .word __arm64x_redirection_metadata_count
         .rva __os_arm64x_get_x64_information
         .rva __os_arm64x_set_x64_information
         .rva __arm64x_extra_rfe_table
diff --git a/lld/test/COFF/arm64ec-cust-export-thunk.s b/lld/test/COFF/arm64ec-cust-export-thunk.s
new file mode 100644
index 000000000000..c99b88eedba0
--- /dev/null
+++ b/lld/test/COFF/arm64ec-cust-export-thunk.s
@@ -0,0 +1,63 @@
+REQUIRES: aarch64, x86
+RUN: split-file %s %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows func.s -o func.obj
+RUN: llvm-mc -filetype=obj -triple=x86_64-windows thunk.s -o thunk.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+
+RUN: lld-link -out:out.dll -machine:arm64ec func.obj thunk.obj loadconfig-arm64ec.obj \
+RUN:          -dll -noentry -export:#func,EXPORTAS,func
+
+RUN: llvm-objdump -d out.dll | FileCheck -check-prefix=DISASM %s
+DISASM:      Disassembly of section .text:
+DISASM-EMPTY:
+DISASM-NEXT: 0000000180001000 <.text>:
+DISASM-NEXT: 180001000: 52800040     mov     w0, #0x2                // =2
+DISASM-NEXT: 180001004: d65f03c0     ret
+DISASM-NEXT:                 ...
+DISASM-EMPTY:
+DISASM-NEXT: 0000000180002000 <func>:
+DISASM-NEXT: 180002000: b8 03 00 00 00               movl    $0x3, %eax
+DISASM-NEXT: 180002005: c3                           retq
+
+RUN: llvm-objdump -p out.dll | FileCheck -check-prefix=EXPORT %s
+EXPORT:      Ordinal      RVA  Name
+EXPORT-NEXT:       1   0x2000  func
+
+RUN: llvm-readobj --coff-load-config out.dll | FileCheck -check-prefix=CHPE %s
+CHPE:       CodeMap [
+CHPE-NEXT:    0x1000 - 0x1008  ARM64EC
+CHPE-NEXT:    0x2000 - 0x200A  X64
+CHPE-NEXT:  ]
+CHPE-NEXT:  CodeRangesToEntryPoints: 0
+CHPE-NEXT:  RedirectionMetadata [
+CHPE-NEXT:    0x2000 -> 0x1000
+CHPE-NEXT:  ]
+
+RUN: lld-link -out:out2.dll -machine:arm64ec func.obj thunk.obj loadconfig-arm64ec.obj \
+RUN:          -dll -noentry -export:func
+RUN: llvm-objdump -d out2.dll | FileCheck -check-prefix=DISASM %s
+RUN: llvm-objdump -p out2.dll | FileCheck -check-prefix=EXPORT %s
+RUN: llvm-readobj --coff-load-config out2.dll | FileCheck -check-prefix=CHPE %s
+
+#--- func.s
+    .section .text,"xr",discard,"#func$hp_target"
+    .globl "#func$hp_target"
+    .p2align 2, 0x0
+"#func$hp_target":
+    mov w0, #2
+    ret
+
+    .weak_anti_dep func
+func = "EXP+#func"
+    .weak_anti_dep "#func"
+"#func" = "#func$hp_target"
+
+#--- thunk.s
+    .section .wowthk$aa,"xr",discard,"EXP+#func"
+    .globl "EXP+#func"
+    .p2align 2, 0x0
+"EXP+#func":
+    movl $3, %eax
+    retq
+    .rva "#func$hp_target"
diff --git a/lld/test/COFF/arm64ec-export-thunks.test b/lld/test/COFF/arm64ec-export-thunks.test
index c8ed53fe7b1f..78b5f52a1e1f 100644
--- a/lld/test/COFF/arm64ec-export-thunks.test
+++ b/lld/test/COFF/arm64ec-export-thunks.test
@@ -57,6 +57,11 @@ EXP-CHPE:       CodeMap [
 EXP-CHPE-NEXT:    0x1000 - 0x100C  ARM64EC
 EXP-CHPE-NEXT:    0x2000 - 0x3020  X64
 EXP-CHPE-NEXT:  ]
+EXP-CHPE-NEXT:  CodeRangesToEntryPoints: 0
+EXP-CHPE-NEXT:  RedirectionMetadata [
+EXP-CHPE-NEXT:    0x3000 -> 0x1000
+EXP-CHPE-NEXT:    0x3010 -> 0x1000
+EXP-CHPE-NEXT:  ]
 
 RUN: llvm-objdump -s --section=.test exports.dll | FileCheck --check-prefix=EXP-DATA %s
 EXP-DATA: 180006000 10300000 00300000
@@ -99,6 +104,10 @@ ENTRY-CHPE:       CodeMap [
 ENTRY-CHPE-NEXT:    0x1000 - 0x100C  ARM64EC
 ENTRY-CHPE-NEXT:    0x2000 - 0x2010  X64
 ENTRY-CHPE-NEXT:  ]
+ENTRY-CHPE-NEXT:  CodeRangesToEntryPoints: 0
+ENTRY-CHPE-NEXT:  RedirectionMetadata [
+ENTRY-CHPE-NEXT:    0x2000 -> 0x1000
+ENTRY-CHPE-NEXT:  ]
 
 
 #--- arm64ec-func.s
diff --git a/lld/test/COFF/arm64ec-exports.s b/lld/test/COFF/arm64ec-exports.s
index 870540d61046..aff851e2051a 100644
--- a/lld/test/COFF/arm64ec-exports.s
+++ b/lld/test/COFF/arm64ec-exports.s
@@ -31,12 +31,12 @@
 ; EXP-NEXT: Export {
 ; EXP-NEXT:   Ordinal: 4
 ; EXP-NEXT:   Name: exportas_func
-; EXP-NEXT:   RVA: 0x2020
+; EXP-NEXT:   RVA: 0x2010
 ; EXP-NEXT: }
 ; EXP-NEXT: Export {
 ; EXP-NEXT:   Ordinal: 5
 ; EXP-NEXT:   Name: mangled_func
-; EXP-NEXT:   RVA: 0x2010
+; EXP-NEXT:   RVA: 0x2020
 ; EXP-NEXT: }
 ; EXP-NEXT: Export {
 ; EXP-NEXT:   Ordinal: 6
diff --git a/lld/test/COFF/arm64ec-patchable-thunks.test b/lld/test/COFF/arm64ec-patchable-thunks.test
index 62e66222975c..0b5a0987d2ec 100644
--- a/lld/test/COFF/arm64ec-patchable-thunks.test
+++ b/lld/test/COFF/arm64ec-patchable-thunks.test
@@ -33,6 +33,10 @@ PATCH-CHPE:       CodeMap [
 PATCH-CHPE-NEXT:    0x1000 - 0x1008  ARM64EC
 PATCH-CHPE-NEXT:    0x2000 - 0x2010  X64
 PATCH-CHPE-NEXT:  ]
+PATCH-CHPE-NEXT:  CodeRangesToEntryPoints: 0
+PATCH-CHPE-NEXT:  RedirectionMetadata [
+PATCH-CHPE-NEXT:    0x2000 -> 0x1000
+PATCH-CHPE-NEXT:  ]
 
 
 RUN: lld-link -out:test2.dll -machine:arm64ec arm64ec-alias.obj loadconfig-arm64ec.obj -dll -noentry
-- 
2.25.1

