From e03fcac5d2122b6f4fe4f58a82af51937e76dcdb Mon Sep 17 00:00:00 2001
From: Alvin Wong <alvin@alvinhc.com>
Date: Fri, 31 Mar 2023 12:57:45 +0300
Subject: [PATCH 02/21] [asan][test] Fix `TestCases/alloca_*` ptr-to-long cast
 on Windows

64-bit Windows uses 32-bit long so these casts fail to compile with the
error "cast from pointer to smaller type". Change to instead use
uintptr_t like other tests.

Reviewed By: mstorsjo

Differential Revision: https://reviews.llvm.org/D147232
---
 compiler-rt/test/asan/TestCases/alloca_big_alignment.cpp       | 3 ++-
 compiler-rt/test/asan/TestCases/alloca_detect_custom_size_.cpp | 3 ++-
 .../test/asan/TestCases/alloca_instruments_all_paddings.cpp    | 3 ++-
 compiler-rt/test/asan/TestCases/alloca_overflow_partial.cpp    | 3 ++-
 compiler-rt/test/asan/TestCases/alloca_overflow_right.cpp      | 3 ++-
 compiler-rt/test/asan/TestCases/alloca_safe_access.cpp         | 3 ++-
 compiler-rt/test/asan/TestCases/alloca_underflow_left.cpp      | 3 ++-
 7 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/compiler-rt/test/asan/TestCases/alloca_big_alignment.cpp b/compiler-rt/test/asan/TestCases/alloca_big_alignment.cpp
index 0b49424bfae5..a451e873f2e4 100644
--- a/compiler-rt/test/asan/TestCases/alloca_big_alignment.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_big_alignment.cpp
@@ -3,10 +3,11 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(128)));
-  assert(!(reinterpret_cast<long>(str) & 127L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 127L));
   str[index] = '1'; // BOOM
 // CHECK: ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address [[ADDR:0x[0-9a-f]+]]
 // CHECK: WRITE of size 1 at [[ADDR]] thread T0
diff --git a/compiler-rt/test/asan/TestCases/alloca_detect_custom_size_.cpp b/compiler-rt/test/asan/TestCases/alloca_detect_custom_size_.cpp
index 271359bf7097..8b207aa07f2e 100644
--- a/compiler-rt/test/asan/TestCases/alloca_detect_custom_size_.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_detect_custom_size_.cpp
@@ -3,6 +3,7 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 struct A {
   char a[3];
@@ -11,7 +12,7 @@ struct A {
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile struct A str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   str[index].a[0] = '1'; // BOOM
 // CHECK: ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address [[ADDR:0x[0-9a-f]+]]
 // CHECK: WRITE of size 1 at [[ADDR]] thread T0
diff --git a/compiler-rt/test/asan/TestCases/alloca_instruments_all_paddings.cpp b/compiler-rt/test/asan/TestCases/alloca_instruments_all_paddings.cpp
index 5bf6f80ac4ce..912c8b0abaab 100644
--- a/compiler-rt/test/asan/TestCases/alloca_instruments_all_paddings.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_instruments_all_paddings.cpp
@@ -5,10 +5,11 @@
 
 #include "sanitizer/asan_interface.h"
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   char *q = (char *)__asan_region_is_poisoned((char *)str, 64);
   assert(q && ((q - str) == index));
 }
diff --git a/compiler-rt/test/asan/TestCases/alloca_overflow_partial.cpp b/compiler-rt/test/asan/TestCases/alloca_overflow_partial.cpp
index afac40ce6b9a..25c6d75be7a5 100644
--- a/compiler-rt/test/asan/TestCases/alloca_overflow_partial.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_overflow_partial.cpp
@@ -3,10 +3,11 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   str[index] = '1'; // BOOM
 // CHECK: ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address [[ADDR:0x[0-9a-f]+]]
 // CHECK: WRITE of size 1 at [[ADDR]] thread T0
diff --git a/compiler-rt/test/asan/TestCases/alloca_overflow_right.cpp b/compiler-rt/test/asan/TestCases/alloca_overflow_right.cpp
index 615dd1485be1..7ec4b86cdc71 100644
--- a/compiler-rt/test/asan/TestCases/alloca_overflow_right.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_overflow_right.cpp
@@ -3,10 +3,11 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   str[index] = '1'; // BOOM
 // CHECK: ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address [[ADDR:0x[0-9a-f]+]]
 // CHECK: WRITE of size 1 at [[ADDR]] thread T0
diff --git a/compiler-rt/test/asan/TestCases/alloca_safe_access.cpp b/compiler-rt/test/asan/TestCases/alloca_safe_access.cpp
index 1cd0dada7b45..98e31769812b 100644
--- a/compiler-rt/test/asan/TestCases/alloca_safe_access.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_safe_access.cpp
@@ -3,10 +3,11 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   str[index] = '1';
 }
 
diff --git a/compiler-rt/test/asan/TestCases/alloca_underflow_left.cpp b/compiler-rt/test/asan/TestCases/alloca_underflow_left.cpp
index 8720e8cce24b..52cd781c4bb8 100644
--- a/compiler-rt/test/asan/TestCases/alloca_underflow_left.cpp
+++ b/compiler-rt/test/asan/TestCases/alloca_underflow_left.cpp
@@ -3,10 +3,11 @@
 //
 
 #include <assert.h>
+#include <stdint.h>
 
 __attribute__((noinline)) void foo(int index, int len) {
   volatile char str[len] __attribute__((aligned(32)));
-  assert(!(reinterpret_cast<long>(str) & 31L));
+  assert(!(reinterpret_cast<uintptr_t>(str) & 31L));
   str[index] = '1'; // BOOM
 // CHECK: ERROR: AddressSanitizer: dynamic-stack-buffer-overflow on address [[ADDR:0x[0-9a-f]+]]
 // CHECK: WRITE of size 1 at [[ADDR]] thread T0
-- 
2.34.1

