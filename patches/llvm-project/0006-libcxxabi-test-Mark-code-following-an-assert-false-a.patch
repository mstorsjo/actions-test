From 282152606c6dbf2995f9e65dae8e76058aec0f3d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Sun, 2 Apr 2023 01:45:07 +0300
Subject: [PATCH 06/13] [libcxxabi] [test] Mark code following an assert(false)
 as unreachable

With current versions of mingw-w64 headers, code following
assert(false) isn't considered unreachable - thus mark it
as such with __builtin_unreachable(), to avoid warnings (treated as
errors) for a missing return statement.

The root cause does get fixed further upstream in mingw-w64 in
https://github.com/mingw-w64/mingw-w64/commit/1690994f515910a31b9fb7c7bd3a52d4ba987abe
though.

Differential Revision: https://reviews.llvm.org/D147860
---
 libcxxabi/test/cxa_vec_new_overflow_PR41395.pass.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libcxxabi/test/cxa_vec_new_overflow_PR41395.pass.cpp b/libcxxabi/test/cxa_vec_new_overflow_PR41395.pass.cpp
index 16239e75f559..44d369d317dc 100644
--- a/libcxxabi/test/cxa_vec_new_overflow_PR41395.pass.cpp
+++ b/libcxxabi/test/cxa_vec_new_overflow_PR41395.pass.cpp
@@ -18,7 +18,7 @@
 void dummy_ctor(void*) { assert(false && "should not be called"); }
 void dummy_dtor(void*) { assert(false && "should not be called"); }
 
-void *dummy_alloc(size_t) { assert(false && "should not be called"); }
+void *dummy_alloc(size_t) { assert(false && "should not be called"); __builtin_unreachable(); }
 void dummy_dealloc(void*) { assert(false && "should not be called"); }
 void dummy_dealloc_sized(void*, size_t) { assert(false && "should not be called"); }
 
-- 
2.34.1

