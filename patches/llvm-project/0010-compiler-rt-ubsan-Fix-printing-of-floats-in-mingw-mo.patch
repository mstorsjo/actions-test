From 29da081bd49a710636eda3c24884fb0c0ba7baa2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Wed, 12 Apr 2023 08:38:05 +0000
Subject: [PATCH 10/23] [compiler-rt] [ubsan] Fix printing of floats in mingw
 mode

In mingw mode on x86, long doubles are 80 bit - while MSVC mode uses
long doubles that are equal to regular doubles (on all architectures).

In the case of this formatting function, we're calling a MS CRT
provided printf function which expects a 64 bit long double.

Since the long doubles are equal to regular doubles on all MSVC
platforms, just format the number that way. That avoids the potential
ambiguity for the mingw long doubles too.
---
 compiler-rt/lib/ubsan/ubsan_diag.cpp | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/compiler-rt/lib/ubsan/ubsan_diag.cpp b/compiler-rt/lib/ubsan/ubsan_diag.cpp
index 3673e66539d0..d54353416a4f 100644
--- a/compiler-rt/lib/ubsan/ubsan_diag.cpp
+++ b/compiler-rt/lib/ubsan/ubsan_diag.cpp
@@ -214,7 +214,12 @@ static void RenderText(InternalScopedString *Buffer, const char *Message,
       //        printf, and stop using snprintf here.
       char FloatBuffer[32];
 #if SANITIZER_WINDOWS
-      sprintf_s(FloatBuffer, sizeof(FloatBuffer), "%Lg", (long double)A.Float);
+      // On MSVC platforms, long doubles are equal to regular doubles.
+      // In mingw environments on x86, long doubles are 80 bit, but here,
+      // we're calling an MS CRT provided printf function which considers
+      // long doubles to be 64 bit. Just cast the float value to a regular
+      // double to avoid the potential ambiguity in mingw mode.
+      sprintf_s(FloatBuffer, sizeof(FloatBuffer), "%g", (double)A.Float);
 #else
       snprintf(FloatBuffer, sizeof(FloatBuffer), "%Lg", (long double)A.Float);
 #endif
-- 
2.34.1

