From c0beea6f008a0ddb4d1eedd2eb39942c07c6927a Mon Sep 17 00:00:00 2001
From: Alvin Wong <alvin@alvinhc.com>
Date: Sat, 22 Apr 2023 22:17:25 +0300
Subject: [PATCH 5/7] [compiler-rt][interception][win] Add more assembly
 patterns

These assembly patterns are needed to intercept some libc++ and
libunwind functions built by Clang for i686-w64-windows-gnu target.

Reviewed By: mstorsjo

Differential Revision: https://reviews.llvm.org/D148990
---
 .../lib/interception/interception_win.cpp     |  3 +++
 .../tests/interception_win_test.cpp           | 27 +++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/compiler-rt/lib/interception/interception_win.cpp b/compiler-rt/lib/interception/interception_win.cpp
index faaa8ee15381..7e8a78bae89a 100644
--- a/compiler-rt/lib/interception/interception_win.cpp
+++ b/compiler-rt/lib/interception/interception_win.cpp
@@ -492,6 +492,7 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {
     case 0xFF8B:  // 8B FF : mov edi, edi
     case 0xEC8B:  // 8B EC : mov ebp, esp
     case 0xc889:  // 89 C8 : mov eax, ecx
+    case 0xE589:  // 89 E5 : mov ebp, esp
     case 0xC18B:  // 8B C1 : mov eax, ecx
     case 0xC033:  // 33 C0 : xor eax, eax
     case 0xC933:  // 33 C9 : xor ecx, ecx
@@ -641,6 +642,8 @@ static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {
     case 0x24448B:  // 8B 44 24 XX : mov eax, dword ptr [esp + XX]
     case 0x244C8B:  // 8B 4C 24 XX : mov ecx, dword ptr [esp + XX]
     case 0x24548B:  // 8B 54 24 XX : mov edx, dword ptr [esp + XX]
+    case 0x245C8B:  // 8B 5C 24 XX : mov ebx, dword ptr [esp + XX]
+    case 0x246C8B:  // 8B 6C 24 XX : mov ebp, dword ptr [esp + XX]
     case 0x24748B:  // 8B 74 24 XX : mov esi, dword ptr [esp + XX]
     case 0x247C8B:  // 8B 7C 24 XX : mov edi, dword ptr [esp + XX]
       return 4;
diff --git a/compiler-rt/lib/interception/tests/interception_win_test.cpp b/compiler-rt/lib/interception/tests/interception_win_test.cpp
index 01b8d3132c37..7d8866a48031 100644
--- a/compiler-rt/lib/interception/tests/interception_win_test.cpp
+++ b/compiler-rt/lib/interception/tests/interception_win_test.cpp
@@ -283,6 +283,30 @@ const u8 kPatchableCode11[] = {
     0x83, 0x64, 0x24, 0x28, 0x00,   // and     dword ptr [rsp+28h],0
 };
 
+const u8 kPatchableCode12[] = {
+    0x55,                           // push    ebp
+    0x53,                           // push    ebx
+    0x57,                           // push    edi
+    0x56,                           // push    esi
+    0x8b, 0x6c, 0x24, 0x18,         // mov     ebp,dword ptr[esp+18h]
+};
+
+const u8 kPatchableCode13[] = {
+    0x55,                           // push    ebp
+    0x53,                           // push    ebx
+    0x57,                           // push    edi
+    0x56,                           // push    esi
+    0x8b, 0x5c, 0x24, 0x14,         // mov     ebx,dword ptr[esp+14h]
+};
+
+const u8 kPatchableCode14[] = {
+    0x55,                           // push    ebp
+    0x89, 0xe5,                     // mov     ebp,esp
+    0x53,                           // push    ebx
+    0x57,                           // push    edi
+    0x56,                           // push    esi
+};
+
 // A buffer holding the dynamically generated code under test.
 u8* ActiveCode;
 const size_t ActiveCodeLength = 4096;
@@ -679,8 +703,11 @@ TEST(Interception, PatchableFunctionWithTrampoline) {
   EXPECT_FALSE(TestFunctionPatching(kUnpatchableCode9, override, prefix));
 #else
   EXPECT_TRUE(TestFunctionPatching(kPatchableCode3, override, prefix));
+  EXPECT_TRUE(TestFunctionPatching(kPatchableCode12, override, prefix));
+  EXPECT_TRUE(TestFunctionPatching(kPatchableCode13, override, prefix));
 #endif
   EXPECT_FALSE(TestFunctionPatching(kPatchableCode4, override, prefix));
+  EXPECT_TRUE(TestFunctionPatching(kPatchableCode14, override, prefix));
 
   EXPECT_FALSE(TestFunctionPatching(kUnpatchableCode1, override, prefix));
   EXPECT_FALSE(TestFunctionPatching(kUnpatchableCode2, override, prefix));
-- 
2.34.1

