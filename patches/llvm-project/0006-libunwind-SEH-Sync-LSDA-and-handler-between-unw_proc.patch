From 5aeaed62d56d0d66978938940bb283909dd6d801 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Tue, 4 Apr 2023 20:26:20 +0000
Subject: [PATCH 06/21] [libunwind] [SEH] Sync LSDA and handler between
 unw_proc_info_t and DISPATCHER_CONTEXT

For normal C++ unwinding, we get _dispContext initialized by the
prepopulated DISPATCHER_CONTEXT in _GCC_specific_handler, which
we set with __unw_seh_set_disp_ctx.

When doing force unwinding, we step and populate the unw_proc_info_t
struct _info with getInfoFromSEH, but when we execute the handler
via the __libunwind_seh_personality wrapper function, we execute
the handler set in DISPATCHER_CONTEXT.

Whenever updating these fields in either _info or _dispContext,
sync them to the other one too.

This fixes one aspect of the libcxxabi force_unwind*.pass.cpp tests on
x86_64.

Differential Revision: https://reviews.llvm.org/D147637
---
 libunwind/src/UnwindCursor.hpp | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/libunwind/src/UnwindCursor.hpp b/libunwind/src/UnwindCursor.hpp
index 152606e314d9..8b6451c68b46 100644
--- a/libunwind/src/UnwindCursor.hpp
+++ b/libunwind/src/UnwindCursor.hpp
@@ -506,7 +506,14 @@ public:
 #endif
 
   DISPATCHER_CONTEXT *getDispatcherContext() { return &_dispContext; }
-  void setDispatcherContext(DISPATCHER_CONTEXT *disp) { _dispContext = *disp; }
+  void setDispatcherContext(DISPATCHER_CONTEXT *disp) {
+    _dispContext = *disp;
+    _info.lsda = reinterpret_cast<unw_word_t>(_dispContext.HandlerData);
+    if (_dispContext.LanguageHandler) {
+      _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);
+    } else
+      _info.handler = 0;
+  }
 
   // libunwind does not and should not depend on C++ library which means that we
   // need our own definition of inline placement new.
@@ -1981,6 +1988,9 @@ bool UnwindCursor<A, R>::getInfoFromSEH(pint_t pc) {
       uint32_t lastcode = (xdata->CountOfCodes + 1) & ~1;
       const uint32_t *handler = reinterpret_cast<uint32_t *>(&xdata->UnwindCodes[lastcode]);
       _info.lsda = reinterpret_cast<unw_word_t>(handler+1);
+      _dispContext.HandlerData = reinterpret_cast<void *>(_info.lsda);
+      _dispContext.LanguageHandler =
+          reinterpret_cast<EXCEPTION_ROUTINE *>(base + *handler);
       if (*handler) {
         _info.handler = reinterpret_cast<unw_word_t>(__libunwind_seh_personality);
       } else
-- 
2.34.1

