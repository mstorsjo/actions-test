From 1bc2cf41ac8f002c5260a367cefa855952f01b56 Mon Sep 17 00:00:00 2001
From: Jacek Caban <jacek@codeweavers.com>
Date: Sun, 28 Jan 2024 22:39:59 +0100
Subject: [PATCH 39/56] [LLD][WIP] Add ARM64X support, combined.

FIXME: Finish, clean up, split, etc...
---
 lld/COFF/COFFLinkerContext.cpp              |  88 ++-
 lld/COFF/COFFLinkerContext.h                |  54 +-
 lld/COFF/Chunks.cpp                         | 165 +++++-
 lld/COFF/Chunks.h                           |  37 ++
 lld/COFF/Config.h                           |   4 -
 lld/COFF/DLL.cpp                            | 316 ++++++----
 lld/COFF/DLL.h                              |  17 +-
 lld/COFF/Driver.cpp                         | 489 ++++++++-------
 lld/COFF/Driver.h                           |  17 +-
 lld/COFF/DriverUtils.cpp                    |  23 +-
 lld/COFF/ICF.cpp                            |   2 +-
 lld/COFF/InputFiles.cpp                     | 172 ++++--
 lld/COFF/InputFiles.h                       |  17 +-
 lld/COFF/MapFile.cpp                        |   4 +-
 lld/COFF/MarkLive.cpp                       |   2 +-
 lld/COFF/MinGW.cpp                          |  31 +-
 lld/COFF/MinGW.h                            |   8 +-
 lld/COFF/PDB.cpp                            |  44 +-
 lld/COFF/SymbolTable.cpp                    | 128 ++--
 lld/COFF/SymbolTable.h                      |  11 +-
 lld/COFF/Symbols.h                          |   3 +-
 lld/COFF/Writer.cpp                         | 627 ++++++++++++++------
 lld/test/COFF/Inputs/loadconfig-arm64.s     |  46 ++
 lld/test/COFF/arm64ec-codemap.test          |   3 +-
 lld/test/COFF/arm64ec-export-thunks.test    |   4 +-
 lld/test/COFF/arm64ec-patchable-thunks.test |  29 +-
 lld/test/COFF/arm64x-delay-import.test      | 222 +++++++
 lld/test/COFF/arm64x-entry.test             | 101 ++++
 lld/test/COFF/arm64x-export.test            | 120 ++++
 lld/test/COFF/arm64x-import.test            | 326 ++++++++++
 lld/test/COFF/arm64x.test                   |  87 +++
 lld/test/COFF/pdata-arm64ec.test            |  21 +-
 32 files changed, 2441 insertions(+), 777 deletions(-)
 create mode 100644 lld/test/COFF/Inputs/loadconfig-arm64.s
 create mode 100644 lld/test/COFF/arm64x-delay-import.test
 create mode 100644 lld/test/COFF/arm64x-entry.test
 create mode 100644 lld/test/COFF/arm64x-export.test
 create mode 100644 lld/test/COFF/arm64x-import.test
 create mode 100644 lld/test/COFF/arm64x.test

diff --git a/lld/COFF/COFFLinkerContext.cpp b/lld/COFF/COFFLinkerContext.cpp
index 2aba87d71603..3cb7a60d8b5f 100644
--- a/lld/COFF/COFFLinkerContext.cpp
+++ b/lld/COFF/COFFLinkerContext.cpp
@@ -15,11 +15,14 @@
 #include "llvm/BinaryFormat/COFF.h"
 #include "llvm/DebugInfo/CodeView/TypeHashing.h"
 #include "llvm/Demangle/Demangle.h"
+#include "llvm/Object/WindowsMachineFlag.h"
+
+using namespace llvm;
+using namespace llvm::COFF;
 
 namespace lld::coff {
 COFFLinkerContext::COFFLinkerContext()
-    : driver(*this), symtab(*this),
-      ltoTextSection(llvm::COFF::IMAGE_SCN_MEM_EXECUTE),
+    : driver(*this), ltoTextSection(llvm::COFF::IMAGE_SCN_MEM_EXECUTE),
       ltoDataSection(llvm::COFF::IMAGE_SCN_CNT_INITIALIZED_DATA),
       ltoTextSectionChunk(&ltoTextSection.section),
       ltoDataSectionChunk(&ltoDataSection.section),
@@ -40,5 +43,84 @@ COFFLinkerContext::COFFLinkerContext()
       symbolMergingTimer("Symbol Merging", addObjectsTimer),
       publicsLayoutTimer("Publics Stream Layout", totalPdbLinkTimer),
       tpiStreamLayoutTimer("TPI Stream Layout", totalPdbLinkTimer),
-      diskCommitTimer("Commit to Disk", totalPdbLinkTimer) {}
+      diskCommitTimer("Commit to Disk", totalPdbLinkTimer),
+      primaryTarget(*this) {}
+
+static bool compatibleMachineType(COFFLinkerContext &ctx, MachineTypes mt) {
+  if (mt == IMAGE_FILE_MACHINE_UNKNOWN)
+    return true;
+  switch (ctx.config.machine) {
+  case ARM64:
+    return mt == ARM64 || mt == ARM64X;
+  case ARM64EC:
+    return isArm64EC(mt) || mt == AMD64;
+  case ARM64X:
+    return isAnyArm64(mt) || mt == AMD64;
+  default:
+    return ctx.config.machine == mt;
+  }
+}
+
+void COFFLinkerContext::addFile(InputFile *file) {
+  log("Reading " + toString(file));
+  if (file->lazy) {
+    if (auto *f = dyn_cast<BitcodeFile>(file))
+      f->parseLazy();
+    else
+      cast<ObjFile>(file)->parseLazy();
+  } else {
+    file->parse();
+    if (auto *f = dyn_cast<ObjFile>(file)) {
+      objFileInstances.push_back(f);
+    } else if (auto *f = dyn_cast<BitcodeFile>(file)) {
+      if (ltoCompilationDone) {
+        error("LTO object file " + toString(file) +
+              " linked in after doing LTO compilation.");
+      }
+      bitcodeFileInstances.push_back(f);
+    } else if (auto *f = dyn_cast<ImportFile>(file)) {
+      importFileInstances.push_back(f);
+      if (f->chkECSym)
+        driver.pullImportThunkSymbols();
+    }
+  }
+  MachineTypes mt = file->getMachineType();
+  if (config.machine == IMAGE_FILE_MACHINE_UNKNOWN) {
+    setMachine(mt);
+  } else if (!compatibleMachineType(*this, mt)) {
+    error(toString(file) + ": machine type " + machineToStr(mt) +
+          " conflicts with " + machineToStr(config.machine));
+    return;
+  }
+
+  driver.parseDirectives(file);
+}
+
+void COFFLinkerContext::setMachine(MachineTypes machine) {
+  assert(config.machine == IMAGE_FILE_MACHINE_UNKNOWN);
+  if (machine == IMAGE_FILE_MACHINE_UNKNOWN)
+    return;
+
+  config.machine = machine;
+
+  if (machine != ARM64X) {
+    primaryTarget.machine = machine;
+  } else {
+    primaryTarget.machine = ARM64;
+    hybridTarget.emplace(*this);
+    hybridTarget->machine = ARM64EC;
+  }
+
+  driver.addWinSysRootLibSearchPaths();
+}
+
+std::vector<Chunk *> COFFLinkerContext::getChunks() const {
+  std::vector<Chunk *> res;
+  for (ObjFile *file : objFileInstances) {
+    ArrayRef<Chunk *> v = file->getChunks();
+    res.insert(res.end(), v.begin(), v.end());
+  }
+  return res;
+}
+
 } // namespace lld::coff
diff --git a/lld/COFF/COFFLinkerContext.h b/lld/COFF/COFFLinkerContext.h
index 325519069cad..3e1a76c66c4a 100644
--- a/lld/COFF/COFFLinkerContext.h
+++ b/lld/COFF/COFFLinkerContext.h
@@ -11,6 +11,7 @@
 
 #include "Chunks.h"
 #include "Config.h"
+#include "DLL.h"
 #include "DebugTypes.h"
 #include "Driver.h"
 #include "InputFiles.h"
@@ -21,6 +22,26 @@
 
 namespace lld::coff {
 
+class COFFTargetContext {
+public:
+  COFFTargetContext(COFFLinkerContext &ctx) : ctx(ctx), symtab(*this) {}
+
+  llvm::COFF::MachineTypes machine = IMAGE_FILE_MACHINE_UNKNOWN;
+
+  COFFLinkerContext &ctx;
+  SymbolTable symtab;
+  Symbol *entry = nullptr;
+
+  std::vector<Export> exports;
+  llvm::DenseSet<StringRef> directivesExports;
+  bool hadExplicitExports;
+  EdataContents edata;
+  Chunk *edataStart = nullptr;
+  Chunk *edataEnd = nullptr;
+
+  Symbol *delayLoadHelper = nullptr;
+};
+
 class COFFLinkerContext : public CommonLinkerContext {
 public:
   COFFLinkerContext();
@@ -29,7 +50,6 @@ public:
   ~COFFLinkerContext() = default;
 
   LinkerDriver driver;
-  SymbolTable symtab;
   COFFOptTable optTable;
 
   std::vector<ObjFile *> objFileInstances;
@@ -55,6 +75,22 @@ public:
     return c->osidx == 0 ? nullptr : outputSections[c->osidx - 1];
   }
 
+  void addFile(InputFile *file);
+  void setMachine(llvm::COFF::MachineTypes machine);
+
+  std::vector<Arm64XDynamicRelocEntry> arm64xRelocs;
+  void addArm64XReloc(llvm::COFF::Arm64XFixupType type,
+                      lld::coff::Defined *offsetSym,
+                      lld::coff::Chunk *offsetChunk, uint16_t offset,
+                      lld::coff::Defined *sym, lld::coff::Chunk *chunk,
+                      uint64_t value, uint8_t size) {
+    arm64xRelocs.emplace_back(type, offsetSym, offsetChunk, offset, sym, chunk,
+                              value, size);
+  }
+
+  // Returns a list of chunks of selected symbols.
+  std::vector<Chunk *> getChunks() const;
+
   std::vector<std::pair<Chunk *, Defined *>> ECThunks;
 
   // Fake sections for parsing bitcode files.
@@ -89,7 +125,23 @@ public:
   Timer tpiStreamLayoutTimer;
   Timer diskCommitTimer;
 
+  bool ltoCompilationDone = false;
+
   Configuration config;
+  COFFTargetContext primaryTarget;
+  std::optional<COFFTargetContext> hybridTarget;
+
+  void forEachTarget(std::function<void(COFFTargetContext &ctx)> f) {
+    f(primaryTarget);
+    if (hybridTarget)
+      f(*hybridTarget);
+  }
+
+  COFFTargetContext &getTarget(llvm::COFF::MachineTypes machine) {
+    if (hybridTarget && (machine == ARM64EC || machine == AMD64))
+      return *hybridTarget;
+    return primaryTarget;
+  }
 };
 
 } // namespace lld::coff
diff --git a/lld/COFF/Chunks.cpp b/lld/COFF/Chunks.cpp
index dd6c476bd510..da002fae75b7 100644
--- a/lld/COFF/Chunks.cpp
+++ b/lld/COFF/Chunks.cpp
@@ -25,6 +25,7 @@
 
 using namespace llvm;
 using namespace llvm::object;
+using namespace llvm::support;
 using namespace llvm::support::endian;
 using namespace llvm::COFF;
 using llvm::support::ulittle32_t;
@@ -422,7 +423,7 @@ void SectionChunk::applyRelocation(uint8_t *off,
                                    const coff_relocation &rel) const {
   auto *sym = dyn_cast_or_null<Defined>(file->getSymbol(rel.SymbolTableIndex));
 
-  if (sym && getMachine() == AMD64 && file->ctx.config.machine == ARM64EC &&
+  if (sym && getMachine() == AMD64 && isArm64EC(file->ctx.config.machine) &&
       isa<DefinedImportData>(sym)) {
     ImportFile *importFile = cast<DefinedImportData>(sym)->file;
     if (importFile->chkECSym)
@@ -1115,7 +1116,10 @@ void ECCodeRangesChunk::writeTo(uint8_t *buf) const {
 }
 
 size_t ECEntryPointsChunk::getSize() const {
-  return ctx.ECThunks.size() * sizeof(chpe_redirection_entry);
+  if (!ctx.ECThunks.size())
+    return 0;
+  return ctx.ECThunks.size() * sizeof(chpe_redirection_entry) +
+         8 /* +8 as a test to match native */;
 }
 
 void ECEntryPointsChunk::writeTo(uint8_t *buf) const {
@@ -1129,4 +1133,161 @@ void ECEntryPointsChunk::writeTo(uint8_t *buf) const {
   }
 }
 
+uint32_t Arm64XDynamicRelocEntry::getRVA() const {
+  return (offsetSym ? offsetSym->getRVA() : 0) +
+         (offsetChunk ? offsetChunk->getRVA() : 0) + offset;
+}
+
+size_t Arm64XDynamicRelocEntry::getSize() const {
+  switch (type) {
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL:
+    return sizeof(uint16_t);
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE:
+    return sizeof(uint16_t) + size;
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA:
+    return 2 * sizeof(uint16_t);
+  }
+}
+
+uint64_t Arm64XDynamicRelocEntry::getValue() const {
+  return (sym ? sym->getRVA() : 0) + (chunk ? chunk->getRVA() : 0) + value;
+}
+
+void Arm64XDynamicRelocEntry::writeTo(uint8_t *buf) const {
+  uint64_t value = getValue();
+  uint16_t h = (getRVA() & 0xfff) | (type << 12);
+
+  switch (type) {
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL:
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE:
+    switch (size) {
+    case 2:
+      h |= 1 << 14;
+      break;
+    case 4:
+      h |= 2 << 14;
+      break;
+    case 8:
+      h |= 3 << 14;
+      break;
+    default:
+      llvm_unreachable("invalid size");
+    }
+    break;
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA:
+    if (static_cast<int>(value) < 0) {
+      h |= 1 << 14;
+      value = -static_cast<int>(value);
+    }
+    if (value & 7) {
+      assert(!(value & 3));
+      value >>= 2;
+    } else {
+      h |= 1 << 15;
+      value >>= 3;
+    }
+    break;
+  }
+
+  auto out = reinterpret_cast<ulittle16_t *>(buf);
+  *out = h;
+
+  switch (type) {
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL:
+    break;
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE:
+    switch (size) {
+    case 2:
+      out[1] = value;
+      break;
+    case 4:
+      *reinterpret_cast<ulittle32_t *>(out + 1) = value;
+      break;
+    case 8:
+      *reinterpret_cast<ulittle64_t *>(out + 1) = value;
+      break;
+    }
+    break;
+  case IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA:
+    out[1] = value;
+    break;
+  }
+}
+
+DynamicRelocsChunk::DynamicRelocsChunk(
+    std::vector<Arm64XDynamicRelocEntry> &arm64xRelocs)
+    : arm64xRelocs(arm64xRelocs) {
+
+  llvm::stable_sort(arm64xRelocs, [=](const Arm64XDynamicRelocEntry &a,
+                                      const Arm64XDynamicRelocEntry &b) {
+    if (a.offsetSym)
+      return a.offsetSym < b.offsetSym;
+    if (b.offsetSym)
+      return true;
+    return a.getRVA() < b.getRVA();
+  });
+
+  uint32_t prevPage = ~0;
+  for (const Arm64XDynamicRelocEntry &entry : arm64xRelocs) {
+    uint32_t page = entry.getRVA() & ~0xfff;
+    if (entry.offsetSym || entry.offsetChunk) {
+      arm64xRelocsSize +=
+          sizeof(coff_base_reloc_block_header) + sizeof(uint16_t);
+    } else if (page != prevPage) {
+      arm64xRelocsSize +=
+          sizeof(coff_base_reloc_block_header) + sizeof(uint16_t);
+      prevPage = page;
+    }
+    arm64xRelocsSize += entry.getSize();
+  }
+}
+
+size_t DynamicRelocsChunk::getSize() const {
+  return alignTo(sizeof(llvm::object::coff_dynamic_reloc_table),
+                 sizeof(uint64_t)) +
+         sizeof(coff_dynamic_relocation64) + arm64xRelocsSize;
+}
+
+void DynamicRelocsChunk::writeTo(uint8_t *buf) const {
+  llvm::stable_sort(arm64xRelocs, [=](const Arm64XDynamicRelocEntry &a,
+                                      const Arm64XDynamicRelocEntry &b) {
+    return a.getRVA() < b.getRVA();
+  });
+
+  auto table = reinterpret_cast<coff_dynamic_reloc_table *>(buf);
+  table->Version = 1;
+  table->Size = sizeof(coff_dynamic_relocation64);
+  buf += sizeof(*table);
+
+  auto header = reinterpret_cast<coff_dynamic_relocation64 *>(buf);
+  header->Symbol = IMAGE_DYNAMIC_RELOCATION_ARM64X;
+  buf += sizeof(*header);
+
+  auto pageHeader = reinterpret_cast<coff_base_reloc_block_header *>(buf);
+  pageHeader->BlockSize = sizeof(*pageHeader);
+  size_t relocSize = sizeof(*pageHeader);
+  for (const Arm64XDynamicRelocEntry &entry : arm64xRelocs) {
+    uint32_t page = entry.getRVA() & ~0xfff;
+    if (page != pageHeader->PageRVA) {
+      pageHeader->BlockSize = alignTo(pageHeader->BlockSize, sizeof(uint32_t));
+      relocSize = alignTo(relocSize, sizeof(uint32_t));
+      pageHeader =
+          reinterpret_cast<coff_base_reloc_block_header *>(buf + relocSize);
+      pageHeader->PageRVA = page;
+      pageHeader->BlockSize = sizeof(*pageHeader);
+      relocSize += sizeof(*pageHeader);
+    }
+
+    entry.writeTo(buf + relocSize);
+    size_t entrySize = entry.getSize();
+    pageHeader->BlockSize += entrySize;
+    relocSize += entrySize;
+  }
+  pageHeader->BlockSize = alignTo(pageHeader->BlockSize, sizeof(uint32_t));
+  relocSize = alignTo(relocSize, sizeof(uint32_t));
+
+  header->BaseRelocSize = relocSize;
+  table->Size += relocSize;
+}
+
 } // namespace lld::coff
diff --git a/lld/COFF/Chunks.h b/lld/COFF/Chunks.h
index 0f991bb0feb9..511170b0d444 100644
--- a/lld/COFF/Chunks.h
+++ b/lld/COFF/Chunks.h
@@ -901,6 +901,43 @@ public:
   SectionChunk chunk;
 };
 
+class Arm64XDynamicRelocEntry {
+public:
+  Arm64XDynamicRelocEntry(llvm::COFF::Arm64XFixupType type, Defined *offsetSym,
+                          Chunk *offsetChunk, uint16_t offset, Defined *sym,
+                          Chunk *chunk, uint64_t value, uint8_t size)
+      : offsetSym(offsetSym), offsetChunk(offsetChunk), type(type),
+        offset(offset), sym(sym), chunk(chunk), value(value), size(size) {}
+
+  size_t getSize() const;
+  void writeTo(uint8_t *buf) const;
+  uint32_t getRVA() const;
+  uint64_t getValue() const;
+  void setValue(uint64_t v) { value = v; }
+
+  Defined *offsetSym;
+  Chunk *offsetChunk;
+
+private:
+  llvm::COFF::Arm64XFixupType type;
+  uint16_t offset;
+  Defined *sym;
+  Chunk *chunk;
+  uint64_t value;
+  uint8_t size;
+};
+
+class DynamicRelocsChunk : public NonSectionChunk {
+public:
+  DynamicRelocsChunk(std::vector<Arm64XDynamicRelocEntry> &arm64xRelocs);
+  size_t getSize() const override;
+  void writeTo(uint8_t *buf) const override;
+
+private:
+  std::vector<Arm64XDynamicRelocEntry> &arm64xRelocs;
+  size_t arm64xRelocsSize = 0;
+};
+
 } // namespace lld::coff
 
 namespace llvm {
diff --git a/lld/COFF/Config.h b/lld/COFF/Config.h
index 6d39796a1025..2ff90ab55b3c 100644
--- a/lld/COFF/Config.h
+++ b/lld/COFF/Config.h
@@ -117,7 +117,6 @@ struct Configuration {
   size_t wordsize;
   bool verbose = false;
   WindowsSubsystem subsystem = llvm::COFF::IMAGE_SUBSYSTEM_UNKNOWN;
-  Symbol *entry = nullptr;
   bool noEntry = false;
   std::string outputFile;
   std::string importName;
@@ -159,11 +158,8 @@ struct Configuration {
   bool dll = false;
   StringRef implib;
   bool noimplib = false;
-  std::vector<Export> exports;
-  bool hadExplicitExports;
   std::set<std::string> delayLoads;
   std::map<std::string, int> dllOrder;
-  Symbol *delayLoadHelper = nullptr;
   Symbol *arm64ECIcallHelper = nullptr;
   Symbol *arm64XDispatchIcall = nullptr;
 
diff --git a/lld/COFF/DLL.cpp b/lld/COFF/DLL.cpp
index c2d0f45deae4..2914d3deaf4d 100644
--- a/lld/COFF/DLL.cpp
+++ b/lld/COFF/DLL.cpp
@@ -165,7 +165,7 @@ private:
 
 static std::vector<std::vector<DefinedImportData *>>
 binImports(COFFLinkerContext &ctx,
-           const std::vector<DefinedImportData *> &imports) {
+           const std::vector<DefinedImportData *> &imports, bool mergeHybrid) {
   // Group DLL-imported symbols by DLL name because that's how
   // symbols are laid out in the import descriptor table.
   auto less = [&ctx](const std::string &a, const std::string &b) {
@@ -176,19 +176,54 @@ binImports(COFFLinkerContext &ctx,
   for (DefinedImportData *sym : imports)
     m[sym->getDLLName().lower()].push_back(sym);
 
+  auto getBaseName = [](StringRef name) {
+    name.consume_front("__imp_");
+    name.consume_front("aux_");
+    return name;
+  };
+
   std::vector<std::vector<DefinedImportData *>> v;
   for (auto &kv : m) {
     // Sort symbols by name for each group.
     std::vector<DefinedImportData *> &syms = kv.second;
-    llvm::sort(syms, [](DefinedImportData *a, DefinedImportData *b) {
-      auto getBaseName = [](StringRef name) {
-        name.consume_front("__imp_");
-        name.consume_front("aux_");
-        return name;
-      };
+    llvm::sort(syms, [getBaseName](DefinedImportData *a, DefinedImportData *b) {
       return getBaseName(a->getName()) < getBaseName(b->getName());
     });
-    v.push_back(std::move(syms));
+    if (!ctx.hybridTarget || syms.empty()) {
+      v.push_back(std::move(syms));
+    } else if (mergeHybrid) {
+      std::vector<DefinedImportData *> hybridSyms;
+      hybridSyms.push_back(syms[0]);
+      for (size_t i = 1; i < syms.size(); ++i) {
+        ImportFile *file = syms[i]->file;
+        ImportFile *prev = hybridSyms.back()->file;
+        if (prev->hybridFile || !file->matches(prev)) {
+          hybridSyms.push_back(syms[i]);
+          continue;
+        }
+
+        if (isArm64EC(file->getMachineType())) {
+          hybridSyms.pop_back();
+          hybridSyms.push_back(syms[i]);
+        }
+
+        prev->hybridFile = file;
+        file->hybridFile = prev;
+      }
+
+      llvm::stable_sort(hybridSyms,
+                        [](DefinedImportData *a, DefinedImportData *b) {
+                          if (a->file->hybridFile)
+                            return !b->file->hybridFile && b->file->isEC();
+                          return !a->file->isEC() && b->file->isEC();
+                        });
+      v.push_back(std::move(hybridSyms));
+    } else {
+      llvm::stable_sort(syms, [](DefinedImportData *a, DefinedImportData *b) {
+        return !a->file->isEC() && b->file->isEC();
+      });
+      v.push_back(std::move(syms));
+    }
   }
   return v;
 }
@@ -707,22 +742,22 @@ public:
 
 class AddressTableChunk : public NonSectionChunk {
 public:
-  explicit AddressTableChunk(COFFLinkerContext &ctx, size_t baseOrdinal,
+  explicit AddressTableChunk(COFFTargetContext &target, size_t baseOrdinal,
                              size_t maxOrdinal)
       : baseOrdinal(baseOrdinal), size((maxOrdinal - baseOrdinal) + 1),
-        ctx(ctx) {}
+        target(target) {}
   size_t getSize() const override { return size * 4; }
 
   void writeTo(uint8_t *buf) const override {
     memset(buf, 0, getSize());
 
-    for (const Export &e : ctx.config.exports) {
+    for (const Export &e : target.exports) {
       assert(e.ordinal >= baseOrdinal && "Export symbol has invalid ordinal");
       // Subtract the OrdinalBase to get the index.
       uint8_t *p = buf + (e.ordinal - baseOrdinal) * 4;
       uint32_t bit = 0;
       // Pointer to thumb code must have the LSB set, so adjust it.
-      if (ctx.config.machine == ARMNT && !e.data)
+      if (target.machine == ARMNT && !e.data)
         bit = 1;
       if (e.forwardChunk) {
         write32le(p, e.forwardChunk->getRVA() | bit);
@@ -737,7 +772,7 @@ public:
 private:
   size_t baseOrdinal;
   size_t size;
-  const COFFLinkerContext &ctx;
+  const COFFTargetContext &target;
 };
 
 class NamePointersChunk : public NonSectionChunk {
@@ -758,13 +793,13 @@ private:
 
 class ExportOrdinalChunk : public NonSectionChunk {
 public:
-  explicit ExportOrdinalChunk(const COFFLinkerContext &ctx, size_t baseOrdinal,
-                              size_t tableSize)
-      : baseOrdinal(baseOrdinal), size(tableSize), ctx(ctx) {}
+  explicit ExportOrdinalChunk(const COFFTargetContext &target,
+                              size_t baseOrdinal, size_t tableSize)
+      : baseOrdinal(baseOrdinal), size(tableSize), target(target) {}
   size_t getSize() const override { return size * 2; }
 
   void writeTo(uint8_t *buf) const override {
-    for (const Export &e : ctx.config.exports) {
+    for (const Export &e : target.exports) {
       if (e.noname)
         continue;
       assert(e.ordinal >= baseOrdinal && "Export symbol has invalid ordinal");
@@ -777,13 +812,14 @@ public:
 private:
   size_t baseOrdinal;
   size_t size;
-  const COFFLinkerContext &ctx;
+  const COFFTargetContext &target;
 };
 
 } // anonymous namespace
 
 void IdataContents::create(COFFLinkerContext &ctx) {
-  std::vector<std::vector<DefinedImportData *>> v = binImports(ctx, imports);
+  std::vector<std::vector<DefinedImportData *>> v =
+      binImports(ctx, imports, true);
 
   // Create .idata contents for each DLL.
   for (std::vector<DefinedImportData *> &syms : v) {
@@ -792,18 +828,46 @@ void IdataContents::create(COFFLinkerContext &ctx) {
     // If they don't (if they are import-by-ordinals), we store only
     // ordinal values to the table.
     size_t base = lookups.size();
+    Chunk *lookupsTerminator = nullptr, *addressesTerminator = nullptr;
     for (DefinedImportData *s : syms) {
       uint16_t ord = s->getOrdinal();
+      HintNameChunk *hintChunk = nullptr;
+      Chunk *lookupsChunk, *addressesChunk;
+
       if (s->getExternalName().empty()) {
-        lookups.push_back(make<OrdinalOnlyChunk>(ctx, ord));
-        addresses.push_back(make<OrdinalOnlyChunk>(ctx, ord));
+        lookupsChunk = make<OrdinalOnlyChunk>(ctx, ord);
+        addressesChunk = make<OrdinalOnlyChunk>(ctx, ord);
       } else {
-        auto *c = make<HintNameChunk>(s->getExternalName(), ord);
-        lookups.push_back(make<LookupChunk>(ctx, c));
-        addresses.push_back(make<LookupChunk>(ctx, c));
-        hints.push_back(c);
+        hintChunk = make<HintNameChunk>(s->getExternalName(), ord);
+        lookupsChunk = make<LookupChunk>(ctx, hintChunk);
+        addressesChunk = make<LookupChunk>(ctx, hintChunk);
+        hints.push_back(hintChunk);
+      }
+
+      if (ctx.hybridTarget && !lookupsTerminator && s->file->isEC() &&
+          !s->file->hybridFile) {
+        lookupsTerminator = lookupsChunk;
+        addressesTerminator = addressesChunk;
+        lookupsChunk = make<NullChunk>(ctx.config.wordsize);
+        addressesChunk = make<NullChunk>(ctx.config.wordsize);
+
+        ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr,
+                           lookupsChunk, 0, nullptr, hintChunk,
+                           hintChunk ? 0 : ord, sizeof(uint64_t));
+        ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr,
+                           addressesChunk, 0, nullptr, hintChunk,
+                           hintChunk ? 0 : ord, sizeof(uint64_t));
+        ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL, nullptr,
+                           lookupsTerminator, 0, nullptr, nullptr, 0,
+                           sizeof(uint64_t));
+        ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_ZEROFILL, nullptr,
+                           addressesTerminator, 0, nullptr, nullptr, 0,
+                           sizeof(uint64_t));
       }
 
+      lookups.push_back(lookupsChunk);
+      addresses.push_back(addressesChunk);
+
       if (s->file->impECSym) {
         Chunk *chkChunk = s->file->chkECSym ? s->file->chkECSym->getChunk() : nullptr;
         auto chunk = make<ECImportChunk>(ctx, chkChunk);
@@ -813,18 +877,27 @@ void IdataContents::create(COFFLinkerContext &ctx) {
         chunk = make<ECImportChunk>(ctx, chkChunk);
         auxIatCopy.push_back(chunk);
         s->file->auxImpCopySym->setLocation(chunk);
+      } else if (ctx.config.machine == ARM64X) {
+        auxIat.push_back(make<NullChunk>(ctx.config.wordsize));
+        auxIatCopy.push_back(make<NullChunk>(ctx.config.wordsize));
       }
     }
     // Terminate with null values.
-    lookups.push_back(make<NullChunk>(ctx.config.wordsize));
-    addresses.push_back(make<NullChunk>(ctx.config.wordsize));
-    if (ctx.config.machine == ARM64EC) {
+    lookups.push_back(lookupsTerminator ? lookupsTerminator
+                                        : make<NullChunk>(ctx.config.wordsize));
+    addresses.push_back(addressesTerminator
+                            ? addressesTerminator
+                            : make<NullChunk>(ctx.config.wordsize));
+    if (isArm64EC(ctx.config.machine)) {
       auxIat.push_back(make<NullChunk>(ctx.config.wordsize));
       auxIatCopy.push_back(make<NullChunk>(ctx.config.wordsize));
     }
 
-    for (int i = 0, e = syms.size(); i < e; ++i)
+    for (int i = 0, e = syms.size(); i < e; ++i) {
       syms[i]->setLocation(addresses[base + i]);
+      if (syms[i]->file->hybridFile)
+        syms[i]->file->hybridFile->impSym->setLocation(addresses[base + i]);
+    }
 
     // Create the import table header.
     dllNames.push_back(make<StringChunk>(syms[0]->getDLLName()));
@@ -832,6 +905,25 @@ void IdataContents::create(COFFLinkerContext &ctx) {
     dir->lookupTab = lookups[base];
     dir->addressTab = addresses[base];
     dirs.push_back(dir);
+
+    if (ctx.hybridTarget) {
+      uint32_t nativeOnly = 0;
+      for (DefinedImportData *s : syms) {
+        if (s->file->isEC())
+          break;
+        ++nativeOnly;
+      }
+      if (nativeOnly) {
+        ctx.addArm64XReloc(
+            IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA, nullptr, dir,
+            offsetof(ImportDirectoryTableEntry, ImportLookupTableRVA), nullptr,
+            nullptr, nativeOnly * sizeof(uint64_t), 0);
+        ctx.addArm64XReloc(
+            IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA, nullptr, dir,
+            offsetof(ImportDirectoryTableEntry, ImportAddressTableRVA), nullptr,
+            nullptr, nativeOnly * sizeof(uint64_t), 0);
+      }
+    }
   }
   // Add null terminator.
   dirs.push_back(make<NullChunk>(sizeof(ImportDirectoryTableEntry)));
@@ -858,69 +950,88 @@ uint64_t DelayLoadContents::getDirSize() {
   return dirs.size() * sizeof(delay_import_directory_table_entry);
 }
 
-void DelayLoadContents::create(Defined *h) {
-  helper = h;
-  std::vector<std::vector<DefinedImportData *>> v = binImports(ctx, imports);
+void DelayLoadContents::create() {
+  std::vector<std::vector<DefinedImportData *>> v =
+      binImports(ctx, imports, false);
 
-  Chunk *unwind = newTailMergeUnwindInfoChunk();
+  Chunk *unwind = newTailMergeUnwindInfoChunk(ctx.primaryTarget);
 
   // Create .didat contents for each DLL.
   for (std::vector<DefinedImportData *> &syms : v) {
     // Create the delay import table header.
     dllNames.push_back(make<StringChunk>(syms[0]->getDLLName()));
     auto *dir = make<DelayDirectoryChunk>(dllNames.back());
-
-    size_t base = addresses.size();
-    Chunk *tm = newTailMergeChunk(dir);
-    Chunk *pdataChunk = unwind ? newTailMergePDataChunk(tm, unwind) : nullptr;
     Chunk *tmEC = nullptr;
-    if (ctx.config.machine == ARM64EC)
-      tmEC = make<DelayHelperChunkARM64EC>(dir, helper);
 
-    for (DefinedImportData *s : syms) {
-      Chunk *t = newThunkChunk(s, tm);
-      auto *a = make<DelayAddressChunk>(ctx, t);
-      addresses.push_back(a);
-      thunks.push_back(t);
-      StringRef extName = s->getExternalName();
-      if (extName.empty()) {
-        names.push_back(make<OrdinalOnlyChunk>(ctx, s->getOrdinal()));
-      } else {
-        auto *c = make<HintNameChunk>(extName, 0);
-        names.push_back(make<LookupChunk>(ctx, c));
-        hintNames.push_back(c);
-        // Add a synthetic symbol for this load thunk, using the "__imp___load"
-        // prefix, in case this thunk needs to be added to the list of valid
-        // call targets for Control Flow Guard.
-        StringRef symName = saver().save("__imp___load_" + extName);
-        s->loadThunkSym =
-            cast<DefinedSynthetic>(ctx.symtab.addSynthetic(symName, t));
+    size_t base = addresses.size();
+    ctx.forEachTarget([&](COFFTargetContext &target) {
+      Chunk *tm = newTailMergeChunk(target, dir);
+      Chunk *pdataChunk =
+          unwind ? newTailMergePDataChunk(target, tm, unwind) : nullptr;
+      size_t targetBase = addresses.size();
+      if (target.machine == ARM64EC)
+        tmEC = make<DelayHelperChunkARM64EC>(
+            dir, cast<Defined>(target.delayLoadHelper));
+
+      for (DefinedImportData *s : syms) {
+        if (s->file->isEC() != isArm64EC(target.machine))
+          continue;
+        Chunk *t = newThunkChunk(target, s, tm);
+        auto *a = make<DelayAddressChunk>(target.ctx, t);
+        addresses.push_back(a);
+        s->setLocation(a);
+        thunks.push_back(t);
+        StringRef extName = s->getExternalName();
+        if (extName.empty()) {
+          names.push_back(make<OrdinalOnlyChunk>(target.ctx, s->getOrdinal()));
+        } else {
+          auto *c = make<HintNameChunk>(extName, 0);
+          names.push_back(make<LookupChunk>(target.ctx, c));
+          hintNames.push_back(c);
+          // Add a synthetic symbol for this load thunk, using the
+          // "__imp___load" prefix, in case this thunk needs to be added to the
+          // list of valid call targets for Control Flow Guard.
+          StringRef symName = saver().save("__imp___load_" + extName);
+          s->loadThunkSym =
+              cast<DefinedSynthetic>(target.symtab.addSynthetic(symName, t));
+        }
+
+        if (s->file->impECSym) {
+          auto thunkEC = make<ThunkChunkARM64EC>(s->file, tmEC);
+          thunks.push_back(thunkEC);
+          auto chunk = make<ECImportChunk>(target.ctx, thunkEC);
+          auxIat.push_back(chunk);
+          s->file->impECSym->setLocation(chunk);
+        }
       }
-
-      if (s->file->impECSym) {
-        auto thunkEC = make<ThunkChunkARM64EC>(s->file, tmEC);
-        thunks.push_back(thunkEC);
-        auto chunk = make<ECImportChunk>(ctx, thunkEC);
-        auxIat.push_back(chunk);
-        s->file->impECSym->setLocation(chunk);
+      thunks.push_back(tm);
+      if (tmEC)
+        thunks.push_back(tmEC);
+      if (pdataChunk)
+        pdata.push_back(pdataChunk);
+      StringRef tmName =
+          saver().save("__tailMerge_" + syms[0]->getDLLName().lower());
+      target.symtab.addSynthetic(tmName, tm);
+      // Terminate with null values.
+      addresses.push_back(make<NullChunk>(8));
+      names.push_back(make<NullChunk>(8));
+      if (target.machine == ARM64EC) {
+        auxIat.push_back(make<NullChunk>(8));
+        if (ctx.hybridTarget) {
+          ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA, nullptr, dir,
+                             offsetof(delay_import_directory_table_entry,
+                                      DelayImportAddressTable),
+                             nullptr, nullptr,
+                             (targetBase - base) * sizeof(uint64_t), 0);
+          ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_DELTA, nullptr, dir,
+                             offsetof(delay_import_directory_table_entry,
+                                      DelayImportNameTable),
+                             nullptr, nullptr,
+                             (targetBase - base) * sizeof(uint64_t), 0);
+        }
       }
-    }
-    thunks.push_back(tm);
-    if (tmEC)
-      thunks.push_back(tmEC);
-    if (pdataChunk)
-      pdata.push_back(pdataChunk);
-    StringRef tmName =
-        saver().save("__tailMerge_" + syms[0]->getDLLName().lower());
-    ctx.symtab.addSynthetic(tmName, tm);
-    // Terminate with null values.
-    addresses.push_back(make<NullChunk>(8));
-    names.push_back(make<NullChunk>(8));
-    if (ctx.config.machine == ARM64EC)
-      auxIat.push_back(make<NullChunk>(8));
+    });
 
-    for (int i = 0, e = syms.size(); i < e; ++i)
-      syms[i]->setLocation(addresses[base + i]);
     auto *mh = make<NullChunk>(8);
     mh->setAlignment(8);
     moduleHandles.push_back(mh);
@@ -938,15 +1049,17 @@ void DelayLoadContents::create(Defined *h) {
   dirs.push_back(make<NullChunk>(sizeof(delay_import_directory_table_entry)));
 }
 
-Chunk *DelayLoadContents::newTailMergeChunk(Chunk *dir) {
-  switch (ctx.config.machine) {
+Chunk *DelayLoadContents::newTailMergeChunk(COFFTargetContext &target,
+                                            Chunk *dir) {
+  auto helper = cast<Defined>(target.delayLoadHelper);
+  switch (target.machine) {
   case AMD64:
   case ARM64EC:
     return make<TailMergeChunkX64>(dir, helper);
   case I386:
-    return make<TailMergeChunkX86>(ctx, dir, helper);
+    return make<TailMergeChunkX86>(target.ctx, dir, helper);
   case ARMNT:
-    return make<TailMergeChunkARM>(ctx, dir, helper);
+    return make<TailMergeChunkARM>(target.ctx, dir, helper);
   case ARM64:
     return make<TailMergeChunkARM64>(dir, helper);
   default:
@@ -954,8 +1067,9 @@ Chunk *DelayLoadContents::newTailMergeChunk(Chunk *dir) {
   }
 }
 
-Chunk *DelayLoadContents::newTailMergeUnwindInfoChunk() {
-  switch (ctx.config.machine) {
+Chunk *
+DelayLoadContents::newTailMergeUnwindInfoChunk(COFFTargetContext &target) {
+  switch (target.ctx.config.machine) {
   case AMD64:
     return make<TailMergeUnwindInfoX64>();
     // FIXME: Add support for other architectures.
@@ -963,8 +1077,9 @@ Chunk *DelayLoadContents::newTailMergeUnwindInfoChunk() {
     return nullptr; // Just don't generate unwind info.
   }
 }
-Chunk *DelayLoadContents::newTailMergePDataChunk(Chunk *tm, Chunk *unwind) {
-  switch (ctx.config.machine) {
+Chunk *DelayLoadContents::newTailMergePDataChunk(COFFTargetContext &target,
+                                                 Chunk *tm, Chunk *unwind) {
+  switch (target.machine) {
   case AMD64:
     return make<TailMergePDataChunkX64>(tm, unwind);
     // FIXME: Add support for other architectures.
@@ -973,16 +1088,17 @@ Chunk *DelayLoadContents::newTailMergePDataChunk(Chunk *tm, Chunk *unwind) {
   }
 }
 
-Chunk *DelayLoadContents::newThunkChunk(DefinedImportData *s,
+Chunk *DelayLoadContents::newThunkChunk(COFFTargetContext &target,
+                                        DefinedImportData *s,
                                         Chunk *tailMerge) {
-  switch (ctx.config.machine) {
+  switch (target.machine) {
   case AMD64:
   case ARM64EC:
     return make<ThunkChunkX64>(s, tailMerge);
   case I386:
-    return make<ThunkChunkX86>(ctx, s, tailMerge);
+    return make<ThunkChunkX86>(target.ctx, s, tailMerge);
   case ARMNT:
-    return make<ThunkChunkARM>(ctx, s, tailMerge);
+    return make<ThunkChunkARM>(target.ctx, s, tailMerge);
   case ARM64:
     return make<ThunkChunkARM64>(s, tailMerge);
   default:
@@ -990,9 +1106,9 @@ Chunk *DelayLoadContents::newThunkChunk(DefinedImportData *s,
   }
 }
 
-EdataContents::EdataContents(COFFLinkerContext &ctx) : ctx(ctx) {
+void EdataContents::create(COFFTargetContext &target) {
   unsigned baseOrdinal = 1 << 16, maxOrdinal = 0;
-  for (Export &e : ctx.config.exports) {
+  for (Export &e : target.exports) {
     baseOrdinal = std::min(baseOrdinal, (unsigned)e.ordinal);
     maxOrdinal = std::max(maxOrdinal, (unsigned)e.ordinal);
   }
@@ -1000,15 +1116,16 @@ EdataContents::EdataContents(COFFLinkerContext &ctx) : ctx(ctx) {
   // https://learn.microsoft.com/en-us/cpp/build/reference/export-exports-a-function?view=msvc-170
   assert(baseOrdinal >= 1);
 
-  auto *dllName = make<StringChunk>(sys::path::filename(ctx.config.outputFile));
-  auto *addressTab = make<AddressTableChunk>(ctx, baseOrdinal, maxOrdinal);
+  auto *dllName =
+      make<StringChunk>(sys::path::filename(target.ctx.config.outputFile));
+  auto *addressTab = make<AddressTableChunk>(target, baseOrdinal, maxOrdinal);
   std::vector<Chunk *> names;
-  for (Export &e : ctx.config.exports)
+  for (Export &e : target.exports)
     if (!e.noname)
       names.push_back(make<StringChunk>(e.exportName));
 
   std::vector<Chunk *> forwards;
-  for (Export &e : ctx.config.exports) {
+  for (Export &e : target.exports) {
     if (e.forwardTo.empty())
       continue;
     e.forwardChunk = make<StringChunk>(e.forwardTo);
@@ -1016,7 +1133,8 @@ EdataContents::EdataContents(COFFLinkerContext &ctx) : ctx(ctx) {
   }
 
   auto *nameTab = make<NamePointersChunk>(names);
-  auto *ordinalTab = make<ExportOrdinalChunk>(ctx, baseOrdinal, names.size());
+  auto *ordinalTab =
+      make<ExportOrdinalChunk>(target, baseOrdinal, names.size());
   auto *dir =
       make<ExportDirectoryChunk>(baseOrdinal, maxOrdinal, names.size(), dllName,
                                  addressTab, nameTab, ordinalTab);
diff --git a/lld/COFF/DLL.h b/lld/COFF/DLL.h
index 9af42a6da9d1..3ae1a5f19f44 100644
--- a/lld/COFF/DLL.h
+++ b/lld/COFF/DLL.h
@@ -51,7 +51,7 @@ public:
       ECImports.push_back(file->impECSym);
   }
   bool empty() { return imports.empty(); }
-  void create(Defined *helper);
+  void create();
   std::vector<Chunk *> getChunks();
   std::vector<Chunk *> getDataChunks();
   ArrayRef<Chunk *> getCodeChunks() { return thunks; }
@@ -62,12 +62,13 @@ public:
   uint64_t getDirSize();
 
 private:
-  Chunk *newThunkChunk(DefinedImportData *s, Chunk *tailMerge);
-  Chunk *newTailMergeChunk(Chunk *dir);
-  Chunk *newTailMergePDataChunk(Chunk *tm, Chunk *unwind);
-  Chunk *newTailMergeUnwindInfoChunk();
+  Chunk *newThunkChunk(COFFTargetContext &target, DefinedImportData *s,
+                       Chunk *tailMerge);
+  Chunk *newTailMergeChunk(COFFTargetContext &target, Chunk *dir);
+  Chunk *newTailMergePDataChunk(COFFTargetContext &target, Chunk *tm,
+                                Chunk *unwind);
+  Chunk *newTailMergeUnwindInfoChunk(COFFTargetContext &target);
 
-  Defined *helper;
   std::vector<DefinedImportData *> imports;
   std::vector<DefinedImportData *> ECImports;
   std::vector<Chunk *> dirs;
@@ -88,15 +89,13 @@ private:
 // EdataContents creates all chunks for the DLL export table.
 class EdataContents {
 public:
-  EdataContents(COFFLinkerContext &ctx);
+  void create(COFFTargetContext &target);
   std::vector<Chunk *> chunks;
 
   uint64_t getRVA() { return chunks[0]->getRVA(); }
   uint64_t getSize() {
     return chunks.back()->getRVA() + chunks.back()->getSize() - getRVA();
   }
-
-  COFFLinkerContext &ctx;
 };
 
 } // namespace lld::coff
diff --git a/lld/COFF/Driver.cpp b/lld/COFF/Driver.cpp
index db18ff55d207..becef930892b 100644
--- a/lld/COFF/Driver.cpp
+++ b/lld/COFF/Driver.cpp
@@ -160,8 +160,9 @@ llvm::Triple::ArchType LinkerDriver::getArch() {
   return getMachineArchType(ctx.config.machine);
 }
 
-bool LinkerDriver::findUnderscoreMangle(StringRef sym) {
-  Symbol *s = ctx.symtab.findMangle(mangle(sym));
+bool LinkerDriver::findUnderscoreMangle(COFFTargetContext &target,
+                                        StringRef sym) {
+  Symbol *s = target.symtab.findMangle(mangle(sym));
   return s && !isa<Undefined>(s);
 }
 
@@ -199,24 +200,24 @@ void LinkerDriver::addBuffer(std::unique_ptr<MemoryBuffer> mb,
         addArchiveBuffer(m, "<whole-archive>", filename, memberIndex++);
       return;
     }
-    ctx.symtab.addFile(make<ArchiveFile>(ctx, mbref));
+    ctx.addFile(make<ArchiveFile>(ctx, mbref));
     break;
   case file_magic::bitcode:
-    ctx.symtab.addFile(make<BitcodeFile>(ctx, mbref, "", 0, lazy));
+    ctx.addFile(make<BitcodeFile>(ctx, mbref, "", 0, lazy));
     break;
   case file_magic::coff_object:
   case file_magic::coff_import_library:
-    ctx.symtab.addFile(make<ObjFile>(ctx, mbref, lazy));
+    ctx.addFile(make<ObjFile>(ctx, mbref, lazy));
     break;
   case file_magic::pdb:
-    ctx.symtab.addFile(make<PDBInputFile>(ctx, mbref));
+    ctx.addFile(make<PDBInputFile>(ctx, mbref));
     break;
   case file_magic::coff_cl_gl_object:
     error(filename + ": is not a native COFF file. Recompile without /GL");
     break;
   case file_magic::pecoff_executable:
     if (ctx.config.mingw) {
-      ctx.symtab.addFile(make<DLLFile>(ctx, mbref));
+      ctx.addFile(make<DLLFile>(ctx, mbref));
       break;
     }
     if (filename.ends_with_insensitive(".dll")) {
@@ -281,7 +282,7 @@ void LinkerDriver::addArchiveBuffer(MemoryBufferRef mb, StringRef symName,
   if (magic == file_magic::coff_import_library) {
     InputFile *imp = make<ImportFile>(ctx, mb);
     imp->parentName = parentName;
-    ctx.symtab.addFile(imp);
+    ctx.addFile(imp);
     return;
   }
 
@@ -301,7 +302,7 @@ void LinkerDriver::addArchiveBuffer(MemoryBufferRef mb, StringRef symName,
   }
 
   obj->parentName = parentName;
-  ctx.symtab.addFile(obj);
+  ctx.addFile(obj);
   log("Loaded " + toString(obj) + " for " + symName);
 }
 
@@ -360,6 +361,7 @@ void LinkerDriver::parseDirectives(InputFile *file) {
   StringRef s = file->getDirectives();
   if (s.empty())
     return;
+  COFFTargetContext &target = ctx.getTarget(file->getMachineType());
 
   log("Directives: " + toString(file) + ": " + s);
 
@@ -373,7 +375,7 @@ void LinkerDriver::parseDirectives(InputFile *file) {
     // declarations, many object files may end up with having the
     // same /EXPORT options. In order to save cost of parsing them,
     // we dedup them first.
-    if (!directivesExports.insert(e).second)
+    if (!target.directivesExports.insert(e).second)
       continue;
 
     Export exp = parseExport(e);
@@ -384,12 +386,12 @@ void LinkerDriver::parseDirectives(InputFile *file) {
         exp.extName = saver().save("_" + exp.extName);
     }
     exp.source = ExportSource::Directives;
-    ctx.config.exports.push_back(exp);
+    target.exports.push_back(exp);
   }
 
   // Handle /include: in bulk.
   for (StringRef inc : directives.includes)
-    addUndefined(inc);
+    addUndefined(target, inc);
 
   // Handle /exclude-symbols: in bulk.
   for (StringRef e : directives.excludes) {
@@ -415,13 +417,15 @@ void LinkerDriver::parseDirectives(InputFile *file) {
     case OPT_entry:
       if (!arg->getValue()[0])
         fatal("missing entry point symbol name");
-      ctx.config.entry = addUndefined(mangle(arg->getValue()), true);
+      ctx.forEachTarget([&](COFFTargetContext &target) {
+        target.entry = addUndefined(target, mangle(arg->getValue()), true);
+      });
       break;
     case OPT_failifmismatch:
       checkFailIfMismatch(arg->getValue(), file);
       break;
     case OPT_incl:
-      addUndefined(arg->getValue(), true);
+      addUndefined(target, arg->getValue(), true);
       break;
     case OPT_manifestdependency:
       ctx.config.manifestDependencies.insert(arg->getValue());
@@ -696,18 +700,19 @@ void LinkerDriver::addLibSearchPaths() {
   }
 }
 
-Symbol *LinkerDriver::addUndefined(StringRef name, bool aliasEC) {
-  Symbol *b = ctx.symtab.addUndefined(name);
+Symbol *LinkerDriver::addUndefined(COFFTargetContext &target, StringRef name,
+                                   bool aliasEC) {
+  Symbol *b = target.symtab.addUndefined(name);
   if (!b->isGCRoot) {
     b->isGCRoot = true;
     ctx.config.gcroot.push_back(b);
   }
-  if (aliasEC && ctx.config.machine == ARM64EC && isa<Undefined>(b)) {
+  if (aliasEC && target.machine == ARM64EC && isa<Undefined>(b)) {
     auto u = cast<Undefined>(b);
     if (!u->weakAlias) {
       if (std::optional<std::string> mangledName =
               getArm64ECMangledFunctionName(name)) {
-        u->weakAlias = ctx.symtab.addUndefined(saver().save(*mangledName));
+        u->weakAlias = target.symtab.addUndefined(saver().save(*mangledName));
         if (Undefined *ut = dyn_cast<Undefined>(u->weakAlias)) {
           u->ECAlias = ut;
           ut->ECAlias = u;
@@ -718,21 +723,21 @@ Symbol *LinkerDriver::addUndefined(StringRef name, bool aliasEC) {
   return b;
 }
 
-StringRef LinkerDriver::mangleMaybe(Symbol *s) {
+StringRef LinkerDriver::mangleMaybe(COFFTargetContext &target, Symbol *s) {
   // If the plain symbol name has already been resolved, do nothing.
   Undefined *unmangled = dyn_cast<Undefined>(s);
   if (!unmangled)
     return "";
 
   // Otherwise, see if a similar, mangled symbol exists in the symbol table.
-  Symbol *mangled = ctx.symtab.findMangle(unmangled->getName());
+  Symbol *mangled = target.symtab.findMangle(unmangled->getName());
   if (!mangled)
     return "";
 
   // If we find a similar mangled symbol, make this an alias to it and return
   // its name.
   log(unmangled->getName() + " aliased to " + mangled->getName());
-  unmangled->weakAlias = ctx.symtab.addUndefined(mangled->getName());
+  unmangled->weakAlias = target.symtab.addUndefined(mangled->getName());
   return mangled->getName();
 }
 
@@ -750,16 +755,17 @@ StringRef LinkerDriver::findDefaultEntry() {
                       ? "WinMainCRTStartup"
                       : "mainCRTStartup");
 
+  COFFTargetContext &target = ctx.primaryTarget;
   if (ctx.config.subsystem == IMAGE_SUBSYSTEM_WINDOWS_GUI) {
-    if (findUnderscoreMangle("wWinMain")) {
-      if (!findUnderscoreMangle("WinMain"))
+    if (findUnderscoreMangle(target, "wWinMain")) {
+      if (!findUnderscoreMangle(target, "WinMain"))
         return mangle("wWinMainCRTStartup");
       warn("found both wWinMain and WinMain; using latter");
     }
     return mangle("WinMainCRTStartup");
   }
-  if (findUnderscoreMangle("wmain")) {
-    if (!findUnderscoreMangle("main"))
+  if (findUnderscoreMangle(target, "wmain")) {
+    if (!findUnderscoreMangle(target, "main"))
       return mangle("wmainCRTStartup");
     warn("found both wmain and main; using latter");
   }
@@ -774,10 +780,11 @@ WindowsSubsystem LinkerDriver::inferSubsystem() {
   // Note that link.exe infers the subsystem from the presence of these
   // functions even if /entry: or /nodefaultlib are passed which causes them
   // to not be called.
-  bool haveMain = findUnderscoreMangle("main");
-  bool haveWMain = findUnderscoreMangle("wmain");
-  bool haveWinMain = findUnderscoreMangle("WinMain");
-  bool haveWWinMain = findUnderscoreMangle("wWinMain");
+  COFFTargetContext &target = ctx.primaryTarget;
+  bool haveMain = findUnderscoreMangle(target, "main");
+  bool haveWMain = findUnderscoreMangle(target, "wmain");
+  bool haveWinMain = findUnderscoreMangle(target, "WinMain");
+  bool haveWWinMain = findUnderscoreMangle(target, "wWinMain");
   if (haveMain || haveWMain) {
     if (haveWinMain || haveWWinMain) {
       warn(std::string("found ") + (haveMain ? "main" : "wmain") + " and " +
@@ -944,7 +951,8 @@ std::string LinkerDriver::getImportName(bool asLib) {
 void LinkerDriver::createImportLibrary(bool asLib) {
   llvm::TimeTraceScope timeScope("Create import library");
   std::vector<COFFShortExport> exports;
-  for (Export &e1 : ctx.config.exports) {
+  COFFTargetContext &target = ctx.primaryTarget; // FIXME: ARM64X
+  for (Export &e1 : target.exports) {
     COFFShortExport e2;
     e2.Name = std::string(e1.name);
     e2.SymbolName = std::string(e1.symbolName);
@@ -1000,7 +1008,7 @@ void LinkerDriver::createImportLibrary(bool asLib) {
   }
 }
 
-void LinkerDriver::parseModuleDefs(StringRef path) {
+void LinkerDriver::parseModuleDefs(COFFTargetContext &target, StringRef path) {
   llvm::TimeTraceScope timeScope("Parse def file");
   std::unique_ptr<MemoryBuffer> mb =
       CHECK(MemoryBuffer::getFile(path, /*IsText=*/false,
@@ -1057,7 +1065,7 @@ void LinkerDriver::parseModuleDefs(StringRef path) {
     e2.isPrivate = e1.Private;
     e2.constant = e1.Constant;
     e2.source = ExportSource::ModuleDefinition;
-    ctx.config.exports.push_back(e2);
+    target.exports.push_back(e2);
   }
 }
 
@@ -1090,7 +1098,7 @@ void LinkerDriver::parseOrderFile(StringRef arg) {
 
   // Get a list of all comdat sections for error checking.
   DenseSet<StringRef> set;
-  for (Chunk *c : ctx.symtab.getChunks())
+  for (Chunk *c : ctx.getChunks())
     if (auto *sec = dyn_cast<SectionChunk>(c))
       if (sec->sym)
         set.insert(sec->sym->getName());
@@ -1209,8 +1217,10 @@ static void findKeepUniqueSections(COFFLinkerContext &ctx) {
 
   // Exported symbols could be address-significant in other executables or DSOs,
   // so we conservatively mark them as address-significant.
-  for (Export &r : ctx.config.exports)
-    markAddrsig(r.sym);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    for (Export &r : target.exports)
+      markAddrsig(r.sym);
+  });
 
   // Visit the address-significance table in each object file and mark each
   // referenced symbol as address-significant.
@@ -1326,7 +1336,7 @@ void LinkerDriver::convertResources() {
   }
   ObjFile *f =
       make<ObjFile>(ctx, convertResToCOFF(resources, resourceObjFiles));
-  ctx.symtab.addFile(f);
+  ctx.addFile(f);
   f->includeResourceChunks();
 }
 
@@ -1350,7 +1360,7 @@ void LinkerDriver::maybeMakeECThunk(StringRef name, Symbol *&sym) {
     expName = saver().save("EXP+" + *mangledName);
   else
     expName = saver().save("EXP+" + name);
-  sym = addUndefined(expName);
+  sym = addUndefined(ctx.getTarget(ARM64EC), expName);
   if (auto undef = dyn_cast<Undefined>(sym)) {
     if (!undef->weakAlias) {
       auto thunk = make<ECThunkChunk>(ctx, def);
@@ -1360,10 +1370,13 @@ void LinkerDriver::maybeMakeECThunk(StringRef name, Symbol *&sym) {
 }
 
 void LinkerDriver::pullImportThunkSymbols() {
+  COFFTargetContext &target = ctx.getTarget(ARM64EC);
   if (!ctx.config.arm64ECIcallHelper)
-    ctx.config.arm64ECIcallHelper = addUndefined("__icall_helper_arm64ec");
+    ctx.config.arm64ECIcallHelper =
+        addUndefined(target, "__icall_helper_arm64ec");
   if (!ctx.config.arm64XDispatchIcall)
-    ctx.config.arm64XDispatchIcall = addUndefined("__os_arm64x_dispatch_icall");
+    ctx.config.arm64XDispatchIcall =
+        addUndefined(target, "__os_arm64x_dispatch_icall");
 }
 
 // In MinGW, if no symbols are chosen to be exported, then all symbols are
@@ -1372,18 +1385,19 @@ void LinkerDriver::pullImportThunkSymbols() {
 // explicitly specified. The automatic behavior can be disabled using the
 // -exclude-all-symbols option, so that lld-link behaves like link.exe rather
 // than MinGW in the case that nothing is explicitly exported.
-void LinkerDriver::maybeExportMinGWSymbols(const opt::InputArgList &args) {
+void LinkerDriver::maybeExportMinGWSymbols(COFFTargetContext &target,
+                                           const opt::InputArgList &args) {
   if (!args.hasArg(OPT_export_all_symbols)) {
     if (!ctx.config.dll)
       return;
 
-    if (!ctx.config.exports.empty())
+    if (!target.exports.empty())
       return;
     if (args.hasArg(OPT_exclude_all_symbols))
       return;
   }
 
-  AutoExporter exporter(ctx, excludedSymbols);
+  AutoExporter exporter(target, excludedSymbols);
 
   for (auto *arg : args.filtered(OPT_wholearchive_file))
     if (std::optional<StringRef> path = findFile(arg->getValue()))
@@ -1396,7 +1410,7 @@ void LinkerDriver::maybeExportMinGWSymbols(const opt::InputArgList &args) {
       exporter.addExcludedSymbol(mangle(sym));
   }
 
-  ctx.symtab.forEachSymbol([&](Symbol *s) {
+  target.symtab.forEachSymbol([&](Symbol *s) {
     auto *def = dyn_cast<Defined>(s);
     if (!exporter.shouldExport(def))
       return;
@@ -1413,7 +1427,7 @@ void LinkerDriver::maybeExportMinGWSymbols(const opt::InputArgList &args) {
       if (!(c->getOutputCharacteristics() & IMAGE_SCN_MEM_EXECUTE))
         e.data = true;
     s->isUsedInRegularObj = true;
-    ctx.config.exports.push_back(e);
+    target.exports.push_back(e);
   });
 }
 
@@ -1791,10 +1805,9 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   {
     llvm::TimeTraceScope timeScope2("Machine arg");
     if (auto *arg = args.getLastArg(OPT_machine)) {
-      config->machine = getMachineType(arg->getValue());
+      ctx.setMachine(getMachineType(arg->getValue()));
       if (config->machine == IMAGE_FILE_MACHINE_UNKNOWN)
         fatal(Twine("unknown /machine argument: ") + arg->getValue());
-      addWinSysRootLibSearchPaths();
     }
   }
 
@@ -1881,10 +1894,6 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   for (auto *arg : args.filtered(OPT_alternatename))
     parseAlternateName(arg->getValue());
 
-  // Handle /include
-  for (auto *arg : args.filtered(OPT_incl))
-    addUndefined(arg->getValue());
-
   // Handle /implib
   if (auto *arg = args.getLastArg(OPT_implib))
     config->implib = arg->getValue();
@@ -2189,9 +2198,10 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   // not we assume x64.
   if (config->machine == IMAGE_FILE_MACHINE_UNKNOWN) {
     warn("/machine is not specified. x64 is assumed");
-    config->machine = AMD64;
-    addWinSysRootLibSearchPaths();
+    ctx.setMachine(AMD64);
   }
+  COFFTargetContext &target =
+      ctx.hybridTarget ? *ctx.hybridTarget : ctx.primaryTarget;
   config->wordsize = config->is64() ? 8 : 4;
 
   if (config->printSearchPaths) {
@@ -2208,6 +2218,10 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
     message(buffer);
   }
 
+  // Handle /include
+  for (auto *arg : args.filtered(OPT_incl))
+    addUndefined(target, arg->getValue());
+
   // Process files specified as /defaultlib. These must be processed after
   // addWinSysRootLibSearchPaths(), which is why they are in a separate loop.
   for (auto *arg : args.filtered(OPT_defaultlib))
@@ -2268,19 +2282,20 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
         if (!e.extName.empty() && !isDecorated(e.extName))
           e.extName = saver().save("_" + e.extName);
       }
-      config->exports.push_back(e);
+      target.exports.push_back(e);
     }
   }
 
   // Handle /def
   if (auto *arg = args.getLastArg(OPT_deffile)) {
     // parseModuleDefs mutates Config object.
-    parseModuleDefs(arg->getValue());
+    // FIXME: ARM64X
+    parseModuleDefs(target, arg->getValue());
   }
 
   // Handle generation of import library from a def file.
   if (!args.hasArg(OPT_INPUT, OPT_wholearchive_file)) {
-    fixupExports();
+    ctx.forEachTarget([&](COFFTargetContext &target) { fixupExports(target); });
     if (!config->noimplib)
       createImportLibrary(/*asLib=*/true);
     return;
@@ -2297,44 +2312,47 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   }
 
   // Handle /entry and /dll
-  {
+  ctx.forEachTarget([&](COFFTargetContext &target) {
     llvm::TimeTraceScope timeScope("Entry point");
-    if (auto *arg = args.getLastArg(OPT_entry)) {
+    if (auto *arg = args.getLastArg(OPT_entry)) { // FIXME: ARM64X native entry?
       if (!arg->getValue()[0])
         fatal("missing entry point symbol name");
-      config->entry = addUndefined(mangle(arg->getValue()), true);
-    } else if (!config->entry && !config->noEntry) {
+      target.entry = addUndefined(target, mangle(arg->getValue()), true);
+    } else if (!target.entry && !config->noEntry) {
       if (args.hasArg(OPT_dll)) {
         StringRef s = (config->machine == I386) ? "__DllMainCRTStartup@12"
                                                 : "_DllMainCRTStartup";
-        config->entry = addUndefined(s, true);
+        target.entry = addUndefined(target, s, true);
       } else if (config->driverWdm) {
         // /driver:wdm implies /entry:_NtProcessStartup
-        config->entry = addUndefined(mangle("_NtProcessStartup"), true);
+        target.entry = addUndefined(target, mangle("_NtProcessStartup"), true);
       } else {
         // Windows specific -- If entry point name is not given, we need to
         // infer that from user-defined entry name.
         StringRef s = findDefaultEntry();
         if (s.empty())
           fatal("entry point must be defined");
-        config->entry = addUndefined(s, true);
+        target.entry = addUndefined(target, s, true);
         log("Entry name inferred: " + s);
       }
     }
-  }
+  });
 
   // Handle /delayload
   {
     llvm::TimeTraceScope timeScope("Delay load");
     for (auto *arg : args.filtered(OPT_delayload)) {
       config->delayLoads.insert(StringRef(arg->getValue()).lower());
-      if (config->machine == I386) {
-        config->delayLoadHelper = addUndefined("___delayLoadHelper2@8");
-      } else if (isArm64EC(config->machine)) {
-        config->delayLoadHelper = addUndefined("#__delayLoadHelper2");
-      } else {
-        config->delayLoadHelper = addUndefined("__delayLoadHelper2");
-      }
+      ctx.forEachTarget([&](COFFTargetContext &target) {
+        if (target.machine == I386) {
+          target.delayLoadHelper =
+              addUndefined(target, "___delayLoadHelper2@8");
+        } else if (isArm64EC(target.machine)) {
+          target.delayLoadHelper = addUndefined(target, "#__delayLoadHelper2");
+        } else {
+          target.delayLoadHelper = addUndefined(target, "__delayLoadHelper2");
+        }
+      });
     }
   }
 
@@ -2403,53 +2421,53 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   if (config->imageBase == uint64_t(-1))
     config->imageBase = getDefaultImageBase();
 
-  ctx.symtab.addSynthetic(mangle("__ImageBase"), nullptr);
-  if (config->machine == I386) {
-    ctx.symtab.addAbsolute("___safe_se_handler_table", 0);
-    ctx.symtab.addAbsolute("___safe_se_handler_count", 0);
-  }
-
-  ctx.symtab.addAbsolute(mangle("__guard_fids_count"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_fids_table"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_flags"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_iat_count"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_iat_table"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_longjmp_count"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_longjmp_table"), 0);
-  // Needed for MSVC 2017 15.5 CRT.
-  ctx.symtab.addAbsolute(mangle("__enclave_config"), 0);
-  // Needed for MSVC 2019 16.8 CRT.
-  ctx.symtab.addAbsolute(mangle("__guard_eh_cont_count"), 0);
-  ctx.symtab.addAbsolute(mangle("__guard_eh_cont_table"), 0);
-
-  if (isArm64EC(config->machine)) {
-    ctx.symtab.addAbsolute("__arm64x_extra_rfe_table", 0);
-    ctx.symtab.addAbsolute("__arm64x_extra_rfe_table_size", 0);
-    ctx.symtab.addAbsolute("__arm64x_native_entrypoint", 0);
-    ctx.symtab.addAbsolute("__arm64x_redirection_metadata", 0);
-    ctx.symtab.addAbsolute("__arm64x_redirection_metadata_count", 0);
-    ctx.symtab.addAbsolute("__guard_check_icall_a64n_fptr", 0);
-    ctx.symtab.addAbsolute("__hybrid_auxiliary_iat", 0);
-    ctx.symtab.addAbsolute("__hybrid_auxiliary_iat_copy", 0);
-    ctx.symtab.addAbsolute("__hybrid_code_map", 0);
-    ctx.symtab.addAbsolute("__hybrid_code_map_count", 0);
-    ctx.symtab.addAbsolute("__x64_code_ranges_to_entry_points", 0);
-    ctx.symtab.addAbsolute("__x64_code_ranges_to_entry_points_count", 0);
-  }
-
-  if (config->pseudoRelocs) {
-    ctx.symtab.addAbsolute(mangle("__RUNTIME_PSEUDO_RELOC_LIST__"), 0);
-    ctx.symtab.addAbsolute(mangle("__RUNTIME_PSEUDO_RELOC_LIST_END__"), 0);
-  }
-  if (config->mingw) {
-    ctx.symtab.addAbsolute(mangle("__CTOR_LIST__"), 0);
-    ctx.symtab.addAbsolute(mangle("__DTOR_LIST__"), 0);
-  }
-  if (config->debug || config->buildIDHash != BuildIDHash::None)
-    if (ctx.symtab.findUnderscore("__buildid"))
-      ctx.symtab.addUndefined(mangle("__buildid"));
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    target.symtab.addSynthetic(mangle("__ImageBase"), nullptr);
+    if (target.machine == I386) {
+      target.symtab.addAbsolute("___safe_se_handler_table", 0);
+      target.symtab.addAbsolute("___safe_se_handler_count", 0);
+    }
 
-  run();
+    target.symtab.addAbsolute(mangle("__guard_fids_count"), 0);
+    target.symtab.addAbsolute(mangle("__guard_fids_table"), 0);
+    target.symtab.addAbsolute(mangle("__guard_flags"), 0);
+    target.symtab.addAbsolute(mangle("__guard_iat_count"), 0);
+    target.symtab.addAbsolute(mangle("__guard_iat_table"), 0);
+    target.symtab.addAbsolute(mangle("__guard_longjmp_count"), 0);
+    target.symtab.addAbsolute(mangle("__guard_longjmp_table"), 0);
+    // Needed for MSVC 2017 15.5 CRT.
+    target.symtab.addAbsolute(mangle("__enclave_config"), 0);
+    // Needed for MSVC 2019 16.8 CRT.
+    target.symtab.addAbsolute(mangle("__guard_eh_cont_count"), 0);
+    target.symtab.addAbsolute(mangle("__guard_eh_cont_table"), 0);
+
+    if (target.machine == ARM64EC) {
+      target.symtab.addAbsolute("__arm64x_extra_rfe_table", 0);
+      target.symtab.addAbsolute("__arm64x_extra_rfe_table_size", 0);
+      target.symtab.addAbsolute("__arm64x_native_entrypoint", 0);
+      target.symtab.addAbsolute("__arm64x_redirection_metadata", 0);
+      target.symtab.addAbsolute("__arm64x_redirection_metadata_count", 0);
+      target.symtab.addAbsolute("__guard_check_icall_a64n_fptr", 0);
+      target.symtab.addAbsolute("__hybrid_auxiliary_iat", 0);
+      target.symtab.addAbsolute("__hybrid_auxiliary_iat_copy", 0);
+      target.symtab.addAbsolute("__hybrid_code_map", 0);
+      target.symtab.addAbsolute("__hybrid_code_map_count", 0);
+      target.symtab.addAbsolute("__x64_code_ranges_to_entry_points", 0);
+      target.symtab.addAbsolute("__x64_code_ranges_to_entry_points_count", 0);
+    }
+
+    if (config->pseudoRelocs) {
+      target.symtab.addAbsolute(mangle("__RUNTIME_PSEUDO_RELOC_LIST__"), 0);
+      target.symtab.addAbsolute(mangle("__RUNTIME_PSEUDO_RELOC_LIST_END__"), 0);
+    }
+    if (config->mingw) {
+      target.symtab.addAbsolute(mangle("__CTOR_LIST__"), 0);
+      target.symtab.addAbsolute(mangle("__DTOR_LIST__"), 0);
+    }
+    if (config->debug || config->buildIDHash != BuildIDHash::None)
+      if (target.symtab.findUnderscore("__buildid"))
+        target.symtab.addUndefined(mangle("__buildid"));
+  });
 
   // This code may add new undefined symbols to the link, which may enqueue more
   // symbol resolution tasks, so we need to continue executing tasks until we
@@ -2457,65 +2475,69 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   {
     llvm::TimeTraceScope timeScope("Add unresolved symbols");
     do {
-      // Windows specific -- if entry point is not found,
-      // search for its mangled names.
-      if (config->entry)
-        mangleMaybe(config->entry);
-
-      // Windows specific -- Make sure we resolve all dllexported symbols.
-      for (Export &e : config->exports) {
-        if (!e.forwardTo.empty())
-          continue;
-        e.sym = addUndefined(e.name, true);
-        if (e.source != ExportSource::Directives)
-          e.symbolName = mangleMaybe(e.sym);
-      }
+      ctx.forEachTarget([&](COFFTargetContext &target) {
+        // Windows specific -- if entry point is not found,
+        // search for its mangled names.
+        if (target.entry)
+          mangleMaybe(target, target.entry);
+
+        // Windows specific -- Make sure we resolve all dllexported symbols.
+        for (Export &e : target.exports) {
+          if (!e.forwardTo.empty())
+            continue;
+          e.sym = addUndefined(target, e.name, true);
+          if (e.source != ExportSource::Directives)
+            e.symbolName = mangleMaybe(target, e.sym);
+        }
 
-      // Add weak aliases. Weak aliases is a mechanism to give remaining
-      // undefined symbols final chance to be resolved successfully.
-      for (auto pair : config->alternateNames) {
-        StringRef from = pair.first;
-        StringRef to = pair.second;
-        Symbol *sym = ctx.symtab.find(from);
-        if (!sym)
-          continue;
-        if (auto *u = dyn_cast<Undefined>(sym))
-          if (!u->weakAlias || u->isECAlias()) {
-            u->weakAlias = ctx.symtab.addUndefined(to);
-            if (u->ECAlias) {
-              cast<Undefined>(u->ECAlias)->ECAlias = nullptr;
-              u->ECAlias = nullptr;
+        // Add weak aliases. Weak aliases is a mechanism to give remaining
+        // undefined symbols final chance to be resolved successfully.
+        for (auto pair : config->alternateNames) {
+          StringRef from = pair.first;
+          StringRef to = pair.second;
+          Symbol *sym = target.symtab.find(from);
+          if (!sym)
+            continue;
+          if (auto *u = dyn_cast<Undefined>(sym))
+            if (!u->weakAlias || u->isECAlias()) {
+              u->weakAlias = target.symtab.addUndefined(to);
+              if (u->ECAlias) {
+                cast<Undefined>(u->ECAlias)->ECAlias = nullptr;
+                u->ECAlias = nullptr;
+              }
             }
-          }
-      }
-
-      // If any inputs are bitcode files, the LTO code generator may create
-      // references to library functions that are not explicit in the bitcode
-      // file's symbol table. If any of those library functions are defined in a
-      // bitcode file in an archive member, we need to arrange to use LTO to
-      // compile those archive members by adding them to the link beforehand.
-      if (!ctx.bitcodeFileInstances.empty()) {
-        llvm::Triple TT(
-            ctx.bitcodeFileInstances.front()->obj->getTargetTriple());
-        for (auto *s : lto::LTO::getRuntimeLibcallSymbols(TT))
-          ctx.symtab.addLibcall(s);
-      }
+        }
 
-      // Windows specific -- if __load_config_used can be resolved, resolve it.
-      if (ctx.symtab.findUnderscore("_load_config_used"))
-        addUndefined(mangle("_load_config_used"));
+        // If any inputs are bitcode files, the LTO code generator may create
+        // references to library functions that are not explicit in the bitcode
+        // file's symbol table. If any of those library functions are defined in a
+        // bitcode file in an archive member, we need to arrange to use LTO to
+        // compile those archive members by adding them to the link beforehand.
+        if (!ctx.bitcodeFileInstances.empty()) {
+          llvm::Triple TT(
+                          ctx.bitcodeFileInstances.front()->obj->getTargetTriple());
+          for (auto *s : lto::LTO::getRuntimeLibcallSymbols(TT))
+            target.symtab.addLibcall(s);
+        }
 
-      if (args.hasArg(OPT_include_optional)) {
-        // Handle /includeoptional
-        for (auto *arg : args.filtered(OPT_include_optional))
-          if (isa_and_nonnull<LazyArchive>(ctx.symtab.find(arg->getValue())))
-            addUndefined(arg->getValue());
-      }
+        // Windows specific -- if __load_config_used can be resolved, resolve
+        // it.
+        if (target.symtab.findUnderscore("_load_config_used"))
+          addUndefined(target, mangle("_load_config_used"));
+
+        if (args.hasArg(OPT_include_optional)) {
+          // Handle /includeoptional
+          for (auto *arg : args.filtered(OPT_include_optional))
+            if (isa_and_nonnull<LazyArchive>(
+                    target.symtab.find(arg->getValue())))
+              addUndefined(target, arg->getValue());
+        }
+      });
     } while (run());
   }
 
   // Create wrapped symbols for -wrap option.
-  std::vector<WrappedSymbol> wrapped = addWrappedSymbols(ctx, args);
+  std::vector<WrappedSymbol> wrapped = addWrappedSymbols(target, args);
   // Load more object files that might be needed for wrapped symbols.
   if (!wrapped.empty())
     while (run())
@@ -2542,7 +2564,8 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
     // If it ends up pulling in more object files from static libraries,
     // (and maybe doing more stdcall fixups along the way), this would need
     // to loop these two calls.
-    ctx.symtab.loadMinGWSymbols();
+    ctx.forEachTarget(
+        [](COFFTargetContext &target) { target.symtab.loadMinGWSymbols(); });
     run();
   }
 
@@ -2551,25 +2574,32 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   // unresolvable symbols first, so we don't spend time generating code that
   // will fail to link anyway.
   if (!ctx.bitcodeFileInstances.empty() && !config->forceUnresolved)
-    ctx.symtab.reportUnresolvable();
+    ctx.forEachTarget(
+        [](COFFTargetContext &target) { target.symtab.reportUnresolvable(); });
   if (errorCount())
     return;
 
-  config->hadExplicitExports = !config->exports.empty();
-  if (config->mingw) {
-    // In MinGW, all symbols are automatically exported if no symbols
-    // are chosen to be exported.
-    maybeExportMinGWSymbols(args);
-  }
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    target.hadExplicitExports = !target.exports.empty();
+    if (config->mingw) {
+      // In MinGW, all symbols are automatically exported if no symbols
+      // are chosen to be exported.
+      maybeExportMinGWSymbols(target, args);
+    }
+  });
 
   // Do LTO by compiling bitcode input files to a set of native COFF files then
   // link those files (unless -thinlto-index-only was given, in which case we
   // resolve symbols and write indices, but don't generate native code or link).
-  ctx.symtab.compileBitcodeFiles();
-
-  if (Defined *d =
-          dyn_cast_or_null<Defined>(ctx.symtab.findUnderscore("_tls_used")))
-    config->gcroot.push_back(d);
+  ctx.ltoCompilationDone = true;
+  ctx.forEachTarget(
+      [](COFFTargetContext &target) { target.symtab.compileBitcodeFiles(); });
+
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (Defined *d = dyn_cast_or_null<Defined>(
+            target.symtab.findUnderscore("_tls_used")))
+      config->gcroot.push_back(d);
+  });
 
   // If -thinlto-index-only is given, we should create only "index
   // files" and not object files. Index file creation is already done
@@ -2583,14 +2613,15 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   run();
 
   // Apply symbol renames for -wrap.
-  if (!wrapped.empty())
-    wrapSymbols(ctx, wrapped);
+  if (!wrapped.empty()) {
+    ctx.forEachTarget(
+        [&](COFFTargetContext &target) { wrapSymbols(target, wrapped); });
+  }
 
-  if (ctx.config.machine == ARM64EC) {
-    if (ctx.config.entry)
-      ctx.driver.maybeMakeECThunk(ctx.config.entry->getName(),
-                                  ctx.config.entry);
-    for (Export &e : config->exports) {
+  if (target.machine == ARM64EC) {
+    if (target.entry)
+      ctx.driver.maybeMakeECThunk(target.entry->getName(), target.entry);
+    for (Export &e : target.exports) {
       if (!e.data)
         ctx.driver.maybeMakeECThunk(e.extName.empty() ? e.name : e.extName,
                                     e.sym);
@@ -2598,7 +2629,9 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   }
 
   // Resolve remaining undefined symbols and warn about imported locals.
-  ctx.symtab.resolveRemainingUndefines();
+  ctx.forEachTarget([](COFFTargetContext &target) {
+    target.symtab.resolveRemainingUndefines();
+  });
   if (errorCount())
     return;
 
@@ -2623,38 +2656,49 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   // Windows specific -- when we are creating a .dll file, we also
   // need to create a .lib file. In MinGW mode, we only do that when the
   // -implib option is given explicitly, for compatibility with GNU ld.
-  if (!config->exports.empty() || config->dll) {
-    llvm::TimeTraceScope timeScope("Create .lib exports");
-    fixupExports();
-    if (!config->noimplib && (!config->mingw || !config->implib.empty()))
-      createImportLibrary(/*asLib=*/false);
-    assignExportOrdinals();
-  }
+  bool outputImportLibrary = false;
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (!target.exports.empty() || config->dll) {
+      llvm::TimeTraceScope timeScope("Create .lib exports");
+      fixupExports(target);
+      outputImportLibrary = true;
+    }
+  });
+  if (!config->noimplib && outputImportLibrary &&
+      (!config->mingw || !config->implib.empty()))
+    createImportLibrary(/*asLib=*/false);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (!target.exports.empty() || config->dll)
+      assignExportOrdinals(target);
+  });
 
   // Handle /output-def (MinGW specific).
+  // FIXME: ARM64X
   if (auto *arg = args.getLastArg(OPT_output_def))
-    writeDefFile(arg->getValue(), config->exports);
+    writeDefFile(arg->getValue(), target.exports);
 
-  // Set extra alignment for .comm symbols
-  for (auto pair : config->alignComm) {
-    StringRef name = pair.first;
-    uint32_t alignment = pair.second;
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    // Set extra alignment for .comm symbols
+    for (auto pair : config->alignComm) {
+      StringRef name = pair.first;
+      uint32_t alignment = pair.second;
 
-    Symbol *sym = ctx.symtab.find(name);
-    if (!sym) {
-      warn("/aligncomm symbol " + name + " not found");
-      continue;
-    }
+      Symbol *sym = target.symtab.find(name);
+      if (!sym) {
+        warn("/aligncomm symbol " + name + " not found");
+        continue;
+      }
 
-    // If the symbol isn't common, it must have been replaced with a regular
-    // symbol, which will carry its own alignment.
-    auto *dc = dyn_cast<DefinedCommon>(sym);
-    if (!dc)
-      continue;
+      // If the symbol isn't common, it must have been replaced with a regular
+      // symbol, which will carry its own alignment.
+      auto *dc = dyn_cast<DefinedCommon>(sym);
+      if (!dc)
+        continue;
 
-    CommonChunk *c = dc->getChunk();
-    c->setAlignment(std::max(c->getAlignment(), alignment));
-  }
+      CommonChunk *c = dc->getChunk();
+      c->setAlignment(std::max(c->getAlignment(), alignment));
+    }
+  });
 
   // Windows specific -- Create an embedded or side-by-side manifest.
   // /manifestdependency: enables /manifest unless an explicit /manifest:no is
@@ -2689,7 +2733,7 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
   if (auto *arg = args.getLastArg(OPT_print_symbol_order))
     config->printSymbolOrder = arg->getValue();
 
-  ctx.symtab.initializeEntryThunks();
+  target.symtab.initializeEntryThunks();
 
   // Identify unreferenced COMDAT sections.
   if (config->doGC) {
@@ -2700,14 +2744,17 @@ void LinkerDriver::linkerMain(ArrayRef<const char *> argsArr) {
       // For now, just manually try to retain the known possible personality
       // functions. This doesn't bring in more object files, but only marks
       // functions that already have been included to be retained.
-      for (const char *n : {"__gxx_personality_v0", "__gcc_personality_v0",
-                            "rust_eh_personality"}) {
-        Defined *d = dyn_cast_or_null<Defined>(ctx.symtab.findUnderscore(n));
-        if (d && !d->isGCRoot) {
-          d->isGCRoot = true;
-          config->gcroot.push_back(d);
+      ctx.forEachTarget([&](COFFTargetContext &target) {
+        for (const char *n : {"__gxx_personality_v0", "__gcc_personality_v0",
+                              "rust_eh_personality"}) {
+          Defined *d =
+              dyn_cast_or_null<Defined>(target.symtab.findUnderscore(n));
+          if (d && !d->isGCRoot) {
+            d->isGCRoot = true;
+            config->gcroot.push_back(d);
+          }
         }
-      }
+      });
     }
 
     markLive(ctx);
diff --git a/lld/COFF/Driver.h b/lld/COFF/Driver.h
index ea929a6dde37..3132748e8f6b 100644
--- a/lld/COFF/Driver.h
+++ b/lld/COFF/Driver.h
@@ -112,7 +112,7 @@ private:
   StringRef findLib(StringRef filename);
   StringRef findLibMinGW(StringRef filename);
 
-  bool findUnderscoreMangle(StringRef sym);
+  bool findUnderscoreMangle(COFFTargetContext &target, StringRef sym);
 
   // Determines the location of the sysroot based on `args`, environment, etc.
   void detectWinSysRoot(const llvm::opt::InputArgList &args);
@@ -143,7 +143,7 @@ private:
 
   void createImportLibrary(bool asLib);
 
-  void parseModuleDefs(StringRef path);
+  void parseModuleDefs(COFFTargetContext &target, StringRef path);
 
   // Parse an /order file. If an option is given, the linker places COMDAT
   // sections int he same order as their names appear in the given file.
@@ -163,7 +163,8 @@ private:
   // trees into one resource tree.
   void convertResources();
 
-  void maybeExportMinGWSymbols(const llvm::opt::InputArgList &args);
+  void maybeExportMinGWSymbols(COFFTargetContext &target,
+                               const llvm::opt::InputArgList &args);
 
   // We don't want to add the same file more than once.
   // Files are uniquified by their filesystem and file number.
@@ -171,9 +172,10 @@ private:
 
   std::set<std::string> visitedLibs;
 
-  Symbol *addUndefined(StringRef sym, bool aliasEC = false);
+  Symbol *addUndefined(COFFTargetContext &target, StringRef sym,
+                       bool aliasEC = false);
 
-  StringRef mangleMaybe(Symbol *s);
+  StringRef mangleMaybe(COFFTargetContext &target, Symbol *s);
 
   // Windows specific -- "main" is not the only main function in Windows.
   // You can choose one from these four -- {w,}{WinMain,main}.
@@ -197,7 +199,6 @@ private:
   std::vector<StringRef> filePaths;
   std::vector<MemoryBufferRef> resources;
 
-  llvm::DenseSet<StringRef> directivesExports;
   llvm::DenseSet<StringRef> excludedSymbols;
 
   COFFLinkerContext &ctx;
@@ -261,8 +262,8 @@ private:
 
   // Used for dllexported symbols.
   Export parseExport(StringRef arg);
-  void fixupExports();
-  void assignExportOrdinals();
+  void fixupExports(COFFTargetContext &target);
+  void assignExportOrdinals(COFFTargetContext &target);
 
   // Parses a string in the form of "key=value" and check
   // if value matches previous values for the key.
diff --git a/lld/COFF/DriverUtils.cpp b/lld/COFF/DriverUtils.cpp
index 6e8f74c83be4..1b12ee4347b6 100644
--- a/lld/COFF/DriverUtils.cpp
+++ b/lld/COFF/DriverUtils.cpp
@@ -669,18 +669,18 @@ static StringRef exportSourceName(ExportSource s) {
 
 // Performs error checking on all /export arguments.
 // It also sets ordinals.
-void LinkerDriver::fixupExports() {
+void LinkerDriver::fixupExports(COFFTargetContext &target) {
   llvm::TimeTraceScope timeScope("Fixup exports");
   // Symbol ordinals must be unique.
   std::set<uint16_t> ords;
-  for (Export &e : ctx.config.exports) {
+  for (Export &e : target.exports) {
     if (e.ordinal == 0)
       continue;
     if (!ords.insert(e.ordinal).second)
       fatal("duplicate export ordinal: " + e.name);
   }
 
-  for (Export &e : ctx.config.exports) {
+  for (Export &e : target.exports) {
     if (!e.exportAs.empty()) {
       e.exportName = e.exportAs;
       continue;
@@ -709,7 +709,7 @@ void LinkerDriver::fixupExports() {
   }
 
   if (ctx.config.killAt && ctx.config.machine == I386) {
-    for (Export &e : ctx.config.exports) {
+    for (Export &e : target.exports) {
       e.name = killAt(e.name, true);
       e.exportName = killAt(e.exportName, false);
       e.extName = killAt(e.extName, true);
@@ -718,10 +718,9 @@ void LinkerDriver::fixupExports() {
   }
 
   // Uniquefy by name.
-  DenseMap<StringRef, std::pair<Export *, unsigned>> map(
-      ctx.config.exports.size());
+  DenseMap<StringRef, std::pair<Export *, unsigned>> map(target.exports.size());
   std::vector<Export> v;
-  for (Export &e : ctx.config.exports) {
+  for (Export &e : target.exports) {
     auto pair = map.insert(std::make_pair(e.exportName, std::make_pair(&e, 0)));
     bool inserted = pair.second;
     if (inserted) {
@@ -749,20 +748,20 @@ void LinkerDriver::fixupExports() {
                  Twine(", now in " + exportSourceName(e.source))));
     }
   }
-  ctx.config.exports = std::move(v);
+  target.exports = std::move(v);
 
   // Sort by name.
-  llvm::sort(ctx.config.exports, [](const Export &a, const Export &b) {
+  llvm::sort(target.exports, [](const Export &a, const Export &b) {
     return a.exportName < b.exportName;
   });
 }
 
-void LinkerDriver::assignExportOrdinals() {
+void LinkerDriver::assignExportOrdinals(COFFTargetContext &target) {
   // Assign unique ordinals if default (= 0).
   uint32_t max = 0;
-  for (Export &e : ctx.config.exports)
+  for (Export &e : target.exports)
     max = std::max(max, (uint32_t)e.ordinal);
-  for (Export &e : ctx.config.exports)
+  for (Export &e : target.exports)
     if (e.ordinal == 0)
       e.ordinal = ++max;
   if (max > std::numeric_limits<uint16_t>::max())
diff --git a/lld/COFF/ICF.cpp b/lld/COFF/ICF.cpp
index 3140d094ae0f..c3d068abe6e2 100644
--- a/lld/COFF/ICF.cpp
+++ b/lld/COFF/ICF.cpp
@@ -264,7 +264,7 @@ void ICF::run() {
 
   // Collect only mergeable sections and group by hash value.
   uint32_t nextId = 1;
-  for (Chunk *c : ctx.symtab.getChunks()) {
+  for (Chunk *c : ctx.getChunks()) {
     if (auto *sc = dyn_cast<SectionChunk>(c)) {
       if (isEligible(sc))
         chunks.push_back(sc);
diff --git a/lld/COFF/InputFiles.cpp b/lld/COFF/InputFiles.cpp
index ae866e72542d..e46fbe5e51da 100644
--- a/lld/COFF/InputFiles.cpp
+++ b/lld/COFF/InputFiles.cpp
@@ -53,6 +53,10 @@ using namespace lld::coff;
 using llvm::Triple;
 using llvm::support::ulittle32_t;
 
+COFFTargetContext &InputFile::getTarget() const {
+  return ctx.getTarget(getMachineType());
+}
+
 // Returns the last element of a path, which is supposed to be a filename.
 static StringRef getBasename(StringRef path) {
   return sys::path::filename(path, sys::path::Style::windows);
@@ -73,7 +77,7 @@ std::string lld::toString(const coff::InputFile *file) {
 /// Checks that Source is compatible with being a weak alias to Target.
 /// If Source is Undefined and has no weak alias set, makes it a weak
 /// alias to Target.
-static void checkAndSetWeakAlias(COFFLinkerContext &ctx, InputFile *f,
+static void checkAndSetWeakAlias(COFFTargetContext &targetCtx, InputFile *f,
                                  Symbol *source, Symbol *target) {
   if (auto *u = dyn_cast<Undefined>(source)) {
     if (u->weakAlias && u->weakAlias != target) {
@@ -82,13 +86,13 @@ static void checkAndSetWeakAlias(COFFLinkerContext &ctx, InputFile *f,
       // of another symbol emitted near the weak symbol.
       // Just use the definition from the first object file that defined
       // this weak symbol.
-      if (ctx.config.allowDuplicateWeak)
+      if (targetCtx.ctx.config.allowDuplicateWeak)
         return;
       // FIXME: This should probably check for anti-dependency, needs more
       // testing
-      if (ctx.config.machine == ARM64EC)
+      if (targetCtx.machine == ARM64EC)
         return;
-      ctx.symtab.reportDuplicate(source, f);
+      targetCtx.symtab.reportDuplicate(source, f);
     }
     u->weakAlias = target;
   }
@@ -105,25 +109,35 @@ void ArchiveFile::parse() {
   // Parse a MemoryBufferRef as an archive file.
   file = CHECK(Archive::create(mb), this);
 
-  if (ctx.config.machine == ARM64EC) {
+  if (isArm64EC(ctx.config.machine)) {
     auto symbols = file->ec_symbols();
     if (!symbols)
       fatal("Reading EC symbols failed: " + toString(symbols.takeError()));
     if (!symbols->empty()) {
+      COFFTargetContext &target = ctx.getTarget(ARM64EC);
       for (const Archive::Symbol &sym : *symbols)
-        ctx.symtab.addLazyArchive(this, sym);
+        target.symtab.addLazyArchive(this, sym);
       for (const Archive::Symbol &sym : *symbols) {
         if (std::optional<std::string> demangledName =
                 getArm64ECDemangledFunctionName(sym.getName()))
-          ctx.symtab.addLazyArchive(this, sym, saver().save(*demangledName));
+          target.symtab.addLazyArchive(this, sym, saver().save(*demangledName));
       }
-      return;
+      if (ctx.config.machine != ARM64X)
+        return;
     }
   }
 
   // Read the symbol table to construct Lazy objects.
   for (const Archive::Symbol &sym : file->symbols())
-    ctx.symtab.addLazyArchive(this, sym);
+    ctx.primaryTarget.symtab.addLazyArchive(this, sym);
+
+  if (ctx.config.machine == ARM64EC) {
+    for (const Archive::Symbol &sym : file->symbols()) {
+      if (std::optional<std::string> demangledName =
+              getArm64ECDemangledFunctionName(sym.getName()))
+        ctx.primaryTarget.symtab.addLazyArchive(this, sym, saver().save(*demangledName));
+    }
+  }
 }
 
 // Returns a buffer pointing to a member file containing a given symbol.
@@ -160,6 +174,8 @@ void ObjFile::parseLazy() {
   std::unique_ptr<Binary> coffObjPtr = CHECK(createBinary(mb), this);
   COFFObjectFile *coffObj = cast<COFFObjectFile>(coffObjPtr.get());
   uint32_t numSymbols = coffObj->getNumberOfSymbols();
+  COFFTargetContext &target =
+      ctx.getTarget(MachineTypes(coffObj->getMachine()));
   for (uint32_t i = 0; i < numSymbols; ++i) {
     COFFSymbolRef coffSym = check(coffObj->getSymbol(i));
     if (coffSym.isUndefined() || !coffSym.isExternal() ||
@@ -168,7 +184,7 @@ void ObjFile::parseLazy() {
     StringRef name = check(coffObj->getSymbolName(coffSym));
     if (coffSym.isAbsolute() && ignoredSymbolName(name))
       continue;
-    ctx.symtab.addLazyObject(this, name);
+    target.symtab.addLazyObject(this, name);
     i += coffSym.getNumberOfAuxSymbols();
   }
 }
@@ -193,10 +209,10 @@ void ObjFile::initializeECThunks() {
       auto entry = reinterpret_cast<const ECMapEntry *>(iter);
       switch (entry->type) {
       case Arm64ECThunkType::Entry:
-        ctx.symtab.addEntryThunk(getSymbol(entry->src), getSymbol(entry->dst));
+        ctx.getTarget(ARM64EC).symtab.addEntryThunk(getSymbol(entry->src), getSymbol(entry->dst));
         break;
       case Arm64ECThunkType::Exit:
-        ctx.symtab.addExitThunk(getSymbol(entry->src), getSymbol(entry->dst));
+        ctx.getTarget(ARM64EC).symtab.addExitThunk(getSymbol(entry->src), getSymbol(entry->dst));
         break;
       case Arm64ECThunkType::GuestExit:
         break;
@@ -421,8 +437,8 @@ Symbol *ObjFile::createRegular(COFFSymbolRef sym) {
   if (sym.isExternal()) {
     StringRef name = check(coffObj->getSymbolName(sym));
     if (sc)
-      return ctx.symtab.addRegular(this, name, sym.getGeneric(), sc,
-                                   sym.getValue());
+      return ctx.getTarget(getMachineType())
+          .symtab.addRegular(this, name, sym.getGeneric(), sc, sym.getValue());
     // For MinGW symbols named .weak.* that point to a discarded section,
     // don't create an Undefined symbol. If nothing ever refers to the symbol,
     // everything should be fine. If something actually refers to the symbol
@@ -430,7 +446,8 @@ Symbol *ObjFile::createRegular(COFFSymbolRef sym) {
     // references at the end.
     if (ctx.config.mingw && name.starts_with(".weak."))
       return nullptr;
-    return ctx.symtab.addUndefined(name, this, false);
+    return ctx.getTarget(getMachineType())
+        .symtab.addUndefined(name, this, false);
   }
   if (sc)
     return make<DefinedRegular>(this, /*Name*/ "", /*IsCOMDAT*/ false,
@@ -450,10 +467,12 @@ void ObjFile::initializeSymbols() {
   std::vector<const coff_aux_section_definition *> comdatDefs(
       coffObj->getNumberOfSections() + 1);
 
+  COFFTargetContext &target = ctx.getTarget(getMachineType());
+
   // See a comment for Undefined::isECAlias.
   // FIXME: This should be implemented nicer, but the whole thing
   // is still friagle, so I'm planning another pass at it anyway.
-  if (ctx.config.machine == ARM64EC) {
+  if (target.machine == ARM64EC) {
     for (uint32_t i = 0; i < numSymbols; ++i) {
       COFFSymbolRef coffSym = check(coffObj->getSymbol(i));
       if (coffSym.isUndefined() || !coffSym.isWeakExternal())
@@ -474,11 +493,11 @@ void ObjFile::initializeSymbols() {
       if (*mangledName != targetName)
         continue;
 
-      Symbol *source = ctx.symtab.addUndefined(name, this, false);
-      Symbol *target = ctx.symtab.addUndefined(targetName, this, false);
+      Symbol *sourceS = target.symtab.addUndefined(name, this, false);
+      Symbol *targetS = target.symtab.addUndefined(targetName, this, false);
 
-      auto s = dyn_cast<Undefined>(source);
-      auto t = dyn_cast<Undefined>(target);
+      auto s = dyn_cast<Undefined>(sourceS);
+      auto t = dyn_cast<Undefined>(targetS);
       if (s && !s->weakAlias && !s->isECAlias() && t && !t->weakAlias &&
           !t->isECAlias()) {
         t->ECAlias = s;
@@ -535,7 +554,7 @@ void ObjFile::initializeSymbols() {
   for (auto &kv : weakAliases) {
     Symbol *sym = kv.first;
     uint32_t idx = kv.second;
-    checkAndSetWeakAlias(ctx, this, sym, symbols[idx]);
+    checkAndSetWeakAlias(target, this, sym, symbols[idx]);
   }
 
   // Free the memory used by sparseChunks now that symbol loading is finished.
@@ -544,7 +563,7 @@ void ObjFile::initializeSymbols() {
 
 Symbol *ObjFile::createUndefined(COFFSymbolRef sym) {
   StringRef name = check(coffObj->getSymbolName(sym));
-  return ctx.symtab.addUndefined(name, this, sym.isWeakExternal());
+  return getTarget().symtab.addUndefined(name, this, sym.isWeakExternal());
 }
 
 static const coff_aux_section_definition *findSectionDef(COFFObjectFile *obj,
@@ -573,6 +592,7 @@ void ObjFile::handleComdatSelection(
 
   SectionChunk *leaderChunk = leader->getChunk();
   COMDATType leaderSelection = leaderChunk->selection;
+  COFFTargetContext &target = getTarget();
 
   assert(leader->data && "Comdat leader without SectionChunk?");
   if (isa<BitcodeFile>(leader->file)) {
@@ -614,13 +634,13 @@ void ObjFile::handleComdatSelection(
          Twine((int)leaderSelection) + " in " + toString(leader->getFile()) +
          " and " + Twine((int)selection) + " in " + toString(this))
             .str());
-    ctx.symtab.reportDuplicate(leader, this);
+    target.symtab.reportDuplicate(leader, this);
     return;
   }
 
   switch (selection) {
   case IMAGE_COMDAT_SELECT_NODUPLICATES:
-    ctx.symtab.reportDuplicate(leader, this);
+    target.symtab.reportDuplicate(leader, this);
     break;
 
   case IMAGE_COMDAT_SELECT_ANY:
@@ -630,14 +650,14 @@ void ObjFile::handleComdatSelection(
   case IMAGE_COMDAT_SELECT_SAME_SIZE:
     if (leaderChunk->getSize() != getSection(sym)->SizeOfRawData) {
       if (!ctx.config.mingw) {
-        ctx.symtab.reportDuplicate(leader, this);
+        target.symtab.reportDuplicate(leader, this);
       } else {
         const coff_aux_section_definition *leaderDef = nullptr;
         if (leaderChunk->file)
           leaderDef = findSectionDef(leaderChunk->file->getCOFFObj(),
                                      leaderChunk->getSectionNumber());
         if (!leaderDef || leaderDef->Length != def->Length)
-          ctx.symtab.reportDuplicate(leader, this);
+          target.symtab.reportDuplicate(leader, this);
       }
     }
     break;
@@ -648,7 +668,7 @@ void ObjFile::handleComdatSelection(
     // if the two comdat sections have e.g. different alignment.
     // Match that.
     if (leaderChunk->getContents() != newChunk.getContents())
-      ctx.symtab.reportDuplicate(leader, this, &newChunk, sym.getValue());
+      target.symtab.reportDuplicate(leader, this, &newChunk, sym.getValue());
     break;
   }
 
@@ -687,12 +707,13 @@ std::optional<Symbol *> ObjFile::createDefined(
     bool &prevailing) {
   prevailing = false;
   auto getName = [&]() { return check(coffObj->getSymbolName(sym)); };
+  COFFTargetContext &target = getTarget();
 
   if (sym.isCommon()) {
     auto *c = make<CommonChunk>(sym);
     chunks.push_back(c);
-    return ctx.symtab.addCommon(this, getName(), sym.getValue(),
-                                sym.getGeneric(), c);
+    return target.symtab.addCommon(this, getName(), sym.getValue(),
+                                   sym.getGeneric(), c);
   }
 
   if (sym.isAbsolute()) {
@@ -705,7 +726,7 @@ std::optional<Symbol *> ObjFile::createDefined(
       return nullptr;
 
     if (sym.isExternal())
-      return ctx.symtab.addAbsolute(name, sym);
+      return target.symtab.addAbsolute(name, sym);
     return make<DefinedAbsolute>(ctx, name, sym);
   }
 
@@ -738,7 +759,7 @@ std::optional<Symbol *> ObjFile::createDefined(
 
     if (sym.isExternal()) {
       std::tie(leader, prevailing) =
-          ctx.symtab.addComdat(this, getName(), sym.getGeneric());
+          target.symtab.addComdat(this, getName(), sym.getGeneric());
     } else {
       leader = make<DefinedRegular>(this, /*Name*/ "", /*IsCOMDAT*/ false,
                                     /*IsExternal*/ false, sym.getGeneric());
@@ -784,7 +805,7 @@ std::optional<Symbol *> ObjFile::createDefined(
   return createRegular(sym);
 }
 
-MachineTypes ObjFile::getMachineType() {
+MachineTypes ObjFile::getMachineType() const {
   if (coffObj)
     return static_cast<MachineTypes>(coffObj->getMachine());
   return IMAGE_FILE_MACHINE_UNKNOWN;
@@ -1047,6 +1068,19 @@ void ObjFile::enqueuePdbFile(StringRef path, ObjFile *fromFile) {
 ImportFile::ImportFile(COFFLinkerContext &ctx, MemoryBufferRef m)
     : InputFile(ctx, ImportKind, m), live(!ctx.config.doGC) {}
 
+MachineTypes ImportFile::getMachineType() const {
+  const char *buf = mb.getBufferStart();
+  const auto *hdr = reinterpret_cast<const coff_import_header *>(buf);
+  return MachineTypes((uint16_t)hdr->Machine);
+}
+
+bool ImportFile::matches(const ImportFile *other) const {
+  if (dllName != other->dllName)
+    return false;
+  return getOrdinal() ? getOrdinal() == other->getOrdinal()
+                      : externalName == other->externalName;
+}
+
 void ImportFile::parse() {
   const auto *hdr =
       reinterpret_cast<const coff_import_header *>(mb.getBufferStart());
@@ -1094,22 +1128,24 @@ void ImportFile::parse() {
 
   bool isCode = hdr->getType() == llvm::COFF::IMPORT_CODE;
 
-  if (ctx.config.machine != ARM64EC) {
-    impSym = ctx.symtab.addImportData(impName, this, location);
+  COFFTargetContext &target = getTarget();
+  if (target.machine != ARM64EC) {
+    impSym = target.symtab.addImportData(impName, this, location);
   } else {
     StringRef auxImpName = saver().save("__imp_aux_" + name);
     if (isCode) {
-      impSym = ctx.symtab.addImportData(auxImpName, this, location);
-      impECSym = ctx.symtab.addImportData(impName, this, ECLocation);
+      impSym = target.symtab.addImportData(auxImpName, this, location);
+      impECSym = target.symtab.addImportData(impName, this, ECLocation);
     } else {
-      impSym = ctx.symtab.addImportData(impName, this, location);
-      impECSym = ctx.symtab.addImportData(auxImpName, this, ECLocation);
+      impSym = target.symtab.addImportData(impName, this, location);
+      impECSym = target.symtab.addImportData(auxImpName, this, ECLocation);
     }
     if (!impECSym)
       return;
 
     StringRef auxImpCopyName = saver().save("__auximpcopy_" + name);
-    auxImpCopySym = ctx.symtab.addImportData(auxImpCopyName, this, auxChkLocation);
+    auxImpCopySym =
+        target.symtab.addImportData(auxImpCopyName, this, auxChkLocation);
     if (!auxImpCopySym)
       return;
   }
@@ -1119,34 +1155,35 @@ void ImportFile::parse() {
     return;
 
   if (hdr->getType() == llvm::COFF::IMPORT_CONST)
-    static_cast<void>(ctx.symtab.addImportData(name, this, location));
+    static_cast<void>(target.symtab.addImportData(name, this, location));
 
   // If type is function, we need to create a thunk which jump to an
   // address pointed by the __imp_ symbol. (This allows you to call
   // DLL functions just like regular non-DLL functions.)
   if (isCode) {
-    if (ctx.config.machine != ARM64EC) {
-      thunkSym = ctx.symtab.addImportThunk(name, impSym, hdr->Machine);
+    if (target.machine != ARM64EC) {
+      thunkSym = target.symtab.addImportThunk(name, impSym, hdr->Machine);
     } else {
-      thunkSym = ctx.symtab.addImportThunk(name, impSym, AMD64);
+      thunkSym = target.symtab.addImportThunk(name, impSym, AMD64);
       StringRef auxThunkName =
           saver().save(*getArm64ECMangledFunctionName(name));
-      auxThunkSym = ctx.symtab.addImportThunk(auxThunkName, impECSym, ARM64EC);
+      auxThunkSym = target.symtab.addImportThunk(auxThunkName, impECSym, ARM64EC);
 
       StringRef impChkName = saver().save("__impchk_" + name);
-      chkECSym = ctx.symtab.addImportCheckThunk(impChkName, this);
+      chkECSym = target.symtab.addImportCheckThunk(impChkName, this);
     }
   }
 }
 
 Symbol *ImportFile::findECExitThunkSymbol() const {
+  COFFTargetContext &target = getTarget();
   if (!chkECSym)
     return nullptr;
-  if (Symbol *sym = ctx.symtab.findExitThunk(impECSym))
+  if (Symbol *sym = target.symtab.findExitThunk(impECSym))
     return sym;
-  if (Symbol *sym = ctx.symtab.findExitThunk(thunkSym))
+  if (Symbol *sym = target.symtab.findExitThunk(thunkSym))
     return sym;
-  if (Symbol *sym = ctx.symtab.findExitThunk(impSym))
+  if (Symbol *sym = target.symtab.findExitThunk(impSym))
     return sym;
   return nullptr;
 }
@@ -1182,11 +1219,13 @@ BitcodeFile::~BitcodeFile() = default;
 void BitcodeFile::parse() {
   llvm::StringSaver &saver = lld::saver();
 
+  COFFTargetContext &target = getTarget();
+
   std::vector<std::pair<Symbol *, bool>> comdat(obj->getComdatTable().size());
   for (size_t i = 0; i != obj->getComdatTable().size(); ++i)
     // FIXME: Check nodeduplicate
-    comdat[i] =
-        ctx.symtab.addComdat(this, saver.save(obj->getComdatTable()[i].first));
+    comdat[i] = target.symtab.addComdat(
+        this, saver.save(obj->getComdatTable()[i].first));
   for (const lto::InputFile::Symbol &objSym : obj->symbols()) {
     StringRef symName = saver.save(objSym.getName());
     int comdatIndex = objSym.getComdatIndex();
@@ -1197,7 +1236,7 @@ void BitcodeFile::parse() {
     else
       fakeSC = &ctx.ltoDataSectionChunk.chunk;
     if (objSym.isUndefined()) {
-      sym = ctx.symtab.addUndefined(symName, this, false);
+      sym = target.symtab.addUndefined(symName, this, false);
       if (objSym.isWeak())
         sym->deferUndefined = true;
       // If one LTO object file references (i.e. has an undefined reference to)
@@ -1214,26 +1253,26 @@ void BitcodeFile::parse() {
       if (symName.starts_with("__imp_"))
         sym->isUsedInRegularObj = true;
     } else if (objSym.isCommon()) {
-      sym = ctx.symtab.addCommon(this, symName, objSym.getCommonSize());
+      sym = target.symtab.addCommon(this, symName, objSym.getCommonSize());
     } else if (objSym.isWeak() && objSym.isIndirect()) {
       // Weak external.
-      sym = ctx.symtab.addUndefined(symName, this, true);
+      sym = target.symtab.addUndefined(symName, this, true);
       std::string fallback = std::string(objSym.getCOFFWeakExternalFallback());
-      Symbol *alias = ctx.symtab.addUndefined(saver.save(fallback));
-      checkAndSetWeakAlias(ctx, this, sym, alias);
+      Symbol *alias = target.symtab.addUndefined(saver.save(fallback));
+      checkAndSetWeakAlias(target, this, sym, alias);
     } else if (comdatIndex != -1) {
       if (symName == obj->getComdatTable()[comdatIndex].first) {
         sym = comdat[comdatIndex].first;
         if (cast<DefinedRegular>(sym)->data == nullptr)
           cast<DefinedRegular>(sym)->data = &fakeSC->repl;
       } else if (comdat[comdatIndex].second) {
-        sym = ctx.symtab.addRegular(this, symName, nullptr, fakeSC);
+        sym = target.symtab.addRegular(this, symName, nullptr, fakeSC);
       } else {
-        sym = ctx.symtab.addUndefined(symName, this, false);
+        sym = target.symtab.addUndefined(symName, this, false);
       }
     } else {
-      sym = ctx.symtab.addRegular(this, symName, nullptr, fakeSC, 0,
-                                  objSym.isWeak());
+      sym = target.symtab.addRegular(this, symName, nullptr, fakeSC, 0,
+                                     objSym.isWeak());
     }
     symbols.push_back(sym);
     if (objSym.isUsed())
@@ -1243,12 +1282,13 @@ void BitcodeFile::parse() {
 }
 
 void BitcodeFile::parseLazy() {
+  COFFTargetContext &target = getTarget();
   for (const lto::InputFile::Symbol &sym : obj->symbols())
     if (!sym.isUndefined())
-      ctx.symtab.addLazyObject(this, sym.getName());
+      target.symtab.addLazyObject(this, sym.getName());
 }
 
-MachineTypes BitcodeFile::getMachineType() {
+MachineTypes BitcodeFile::getMachineType() const {
   Triple t(obj->getTargetTriple());
   switch (t.getArch()) {
   case Triple::x86_64:
@@ -1300,6 +1340,8 @@ void DLLFile::parse() {
     return;
   }
 
+  COFFTargetContext &target = getTarget();
+
   for (const auto &exp : coffObj->export_directories()) {
     StringRef dllName, symbolName;
     uint32_t exportRVA;
@@ -1324,13 +1366,13 @@ void DLLFile::parse() {
     }
 
     StringRef impName = saver().save("__imp_" + symbolName);
-    ctx.symtab.addLazyDLLSymbol(this, s, impName);
+    target.symtab.addLazyDLLSymbol(this, s, impName);
     if (code)
-      ctx.symtab.addLazyDLLSymbol(this, s, symbolName);
+      target.symtab.addLazyDLLSymbol(this, s, symbolName);
   }
 }
 
-MachineTypes DLLFile::getMachineType() {
+MachineTypes DLLFile::getMachineType() const {
   if (coffObj)
     return static_cast<MachineTypes>(coffObj->getMachine());
   return IMAGE_FILE_MACHINE_UNKNOWN;
@@ -1359,5 +1401,5 @@ void DLLFile::makeImport(DLLFile::Symbol *s) {
   memcpy(p, s->dllName.data(), s->dllName.size());
   MemoryBufferRef mbref = MemoryBufferRef(StringRef(buf, size), s->dllName);
   ImportFile *impFile = make<ImportFile>(ctx, mbref);
-  ctx.symtab.addFile(impFile);
+  ctx.addFile(impFile);
 }
diff --git a/lld/COFF/InputFiles.h b/lld/COFF/InputFiles.h
index 95d5e2c2e856..0d756c829798 100644
--- a/lld/COFF/InputFiles.h
+++ b/lld/COFF/InputFiles.h
@@ -39,6 +39,7 @@ class DWARFCache;
 
 namespace coff {
 class COFFLinkerContext;
+class COFFTargetContext;
 
 std::vector<MemoryBufferRef> getArchiveMembers(llvm::object::Archive *file);
 
@@ -82,7 +83,10 @@ public:
   virtual void parse() = 0;
 
   // Returns the CPU type this file was compiled to.
-  virtual MachineTypes getMachineType() { return IMAGE_FILE_MACHINE_UNKNOWN; }
+  virtual MachineTypes getMachineType() const {
+    return IMAGE_FILE_MACHINE_UNKNOWN;
+  }
+  COFFTargetContext &getTarget() const;
 
   MemoryBufferRef mb;
 
@@ -133,7 +137,7 @@ public:
   static bool classof(const InputFile *f) { return f->kind() == ObjectKind; }
   void parse() override;
   void parseLazy();
-  MachineTypes getMachineType() override;
+  MachineTypes getMachineType() const override;
   ArrayRef<Chunk *> getChunks() { return chunks; }
   ArrayRef<SectionChunk *> getDebugChunks() { return debugChunks; }
   ArrayRef<SectionChunk *> getSXDataChunks() { return sxDataChunks; }
@@ -342,6 +346,10 @@ public:
   explicit ImportFile(COFFLinkerContext &ctx, MemoryBufferRef m);
 
   static bool classof(const InputFile *f) { return f->kind() == ImportKind; }
+  MachineTypes getMachineType() const override;
+  bool matches(const ImportFile *other) const;
+  uint16_t getOrdinal() const { return hdr->OrdinalHint; }
+  bool isEC() const { return impECSym != nullptr; }
 
   Symbol *findECExitThunkSymbol() const;
 
@@ -351,6 +359,7 @@ public:
   Symbol *thunkSym = nullptr;
   Symbol *auxThunkSym = nullptr;
   DefinedImportThunk *chkECSym = nullptr;
+  ImportFile *hybridFile = nullptr;
   std::string dllName;
 
 private:
@@ -383,7 +392,7 @@ public:
   ~BitcodeFile();
   static bool classof(const InputFile *f) { return f->kind() == BitcodeKind; }
   ArrayRef<Symbol *> getSymbols() { return symbols; }
-  MachineTypes getMachineType() override;
+  MachineTypes getMachineType() const override;
   void parseLazy();
   std::unique_ptr<llvm::lto::InputFile> obj;
 
@@ -400,7 +409,7 @@ public:
       : InputFile(ctx, DLLKind, m) {}
   static bool classof(const InputFile *f) { return f->kind() == DLLKind; }
   void parse() override;
-  MachineTypes getMachineType() override;
+  MachineTypes getMachineType() const override;
 
   struct Symbol {
     StringRef dllName;
diff --git a/lld/COFF/MapFile.cpp b/lld/COFF/MapFile.cpp
index 82b6c52c473d..b09f9859c63f 100644
--- a/lld/COFF/MapFile.cpp
+++ b/lld/COFF/MapFile.cpp
@@ -301,7 +301,7 @@ void lld::coff::writeMapFile(COFFLinkerContext &ctx) {
   uint64_t entryAddress = 0;
 
   if (!ctx.config.noEntry) {
-    Defined *entry = dyn_cast_or_null<Defined>(ctx.config.entry);
+    Defined *entry = dyn_cast_or_null<Defined>(ctx.primaryTarget.entry);
     if (entry) {
       Chunk *chunk = entry->getChunk();
       entrySecIndex = chunk->getOutputSectionIdx();
@@ -326,7 +326,7 @@ void lld::coff::writeMapFile(COFFLinkerContext &ctx) {
     os << " Exports\n";
     os << "\n";
     os << "  ordinal    name\n\n";
-    for (Export &e : ctx.config.exports) {
+    for (Export &e : ctx.primaryTarget.exports) {
       os << format("  %7d", e.ordinal) << "    " << e.name << "\n";
       if (!e.extName.empty() && e.extName != e.name)
         os << "               exported name: " << e.extName << "\n";
diff --git a/lld/COFF/MarkLive.cpp b/lld/COFF/MarkLive.cpp
index 075007d963c1..cde03c2379a1 100644
--- a/lld/COFF/MarkLive.cpp
+++ b/lld/COFF/MarkLive.cpp
@@ -31,7 +31,7 @@ void markLive(COFFLinkerContext &ctx) {
   // COMDAT section chunks are dead by default. Add non-COMDAT chunks. Do not
   // traverse DWARF sections. They are live, but they should not keep other
   // sections alive.
-  for (Chunk *c : ctx.symtab.getChunks())
+  for (Chunk *c : ctx.getChunks())
     if (auto *sc = dyn_cast<SectionChunk>(c))
       if (sc->live && !sc->isDWARF())
         worklist.push_back(sc);
diff --git a/lld/COFF/MinGW.cpp b/lld/COFF/MinGW.cpp
index 29c01da9e28f..c8c78844a848 100644
--- a/lld/COFF/MinGW.cpp
+++ b/lld/COFF/MinGW.cpp
@@ -25,9 +25,9 @@ using namespace lld;
 using namespace lld::coff;
 
 AutoExporter::AutoExporter(
-    COFFLinkerContext &ctx,
+    COFFTargetContext &target,
     const llvm::DenseSet<StringRef> &manualExcludeSymbols)
-    : manualExcludeSymbols(manualExcludeSymbols), ctx(ctx) {
+    : manualExcludeSymbols(manualExcludeSymbols), target(target) {
   excludeLibs = {
       "libgcc",
       "libgcc_s",
@@ -84,7 +84,7 @@ AutoExporter::AutoExporter(
       "_NULL_THUNK_DATA",
   };
 
-  if (ctx.config.machine == I386) {
+  if (target.ctx.config.machine == I386) {
     excludeSymbols = {
         "__NULL_IMPORT_DESCRIPTOR",
         "__pei386_runtime_relocator",
@@ -151,7 +151,7 @@ bool AutoExporter::shouldExport(Defined *sym) const {
       return false;
 
   // If a corresponding __imp_ symbol exists and is defined, don't export it.
-  if (ctx.symtab.find(("__imp_" + sym->getName()).str()))
+  if (target.symtab.find(("__imp_" + sym->getName()).str()))
     return false;
 
   // Check that file is non-null before dereferencing it, symbols not
@@ -204,7 +204,8 @@ static StringRef mangle(Twine sym, MachineTypes machine) {
 // like they are not being used at all, so we explicitly set some flags so
 // that LTO won't eliminate them.
 std::vector<WrappedSymbol>
-lld::coff::addWrappedSymbols(COFFLinkerContext &ctx, opt::InputArgList &args) {
+lld::coff::addWrappedSymbols(COFFTargetContext &target,
+                             opt::InputArgList &args) {
   std::vector<WrappedSymbol> v;
   DenseSet<StringRef> seen;
 
@@ -213,14 +214,14 @@ lld::coff::addWrappedSymbols(COFFLinkerContext &ctx, opt::InputArgList &args) {
     if (!seen.insert(name).second)
       continue;
 
-    Symbol *sym = ctx.symtab.findUnderscore(name);
+    Symbol *sym = target.symtab.findUnderscore(name);
     if (!sym)
       continue;
 
-    Symbol *real =
-        ctx.symtab.addUndefined(mangle("__real_" + name, ctx.config.machine));
-    Symbol *wrap =
-        ctx.symtab.addUndefined(mangle("__wrap_" + name, ctx.config.machine));
+    Symbol *real = target.symtab.addUndefined(
+        mangle("__real_" + name, target.ctx.config.machine));
+    Symbol *wrap = target.symtab.addUndefined(
+        mangle("__wrap_" + name, target.ctx.config.machine));
     v.push_back({sym, real, wrap});
 
     // These symbols may seem undefined initially, but don't bail out
@@ -247,29 +248,29 @@ lld::coff::addWrappedSymbols(COFFLinkerContext &ctx, opt::InputArgList &args) {
 // When this function is executed, only InputFiles and symbol table
 // contain pointers to symbol objects. We visit them to replace pointers,
 // so that wrapped symbols are swapped as instructed by the command line.
-void lld::coff::wrapSymbols(COFFLinkerContext &ctx,
+void lld::coff::wrapSymbols(COFFTargetContext &target,
                             ArrayRef<WrappedSymbol> wrapped) {
   DenseMap<Symbol *, Symbol *> map;
   for (const WrappedSymbol &w : wrapped) {
     map[w.sym] = w.wrap;
     map[w.real] = w.sym;
     if (Defined *d = dyn_cast<Defined>(w.wrap)) {
-      Symbol *imp = ctx.symtab.find(("__imp_" + w.sym->getName()).str());
+      Symbol *imp = target.symtab.find(("__imp_" + w.sym->getName()).str());
       // Create a new defined local import for the wrap symbol. If
       // no imp prefixed symbol existed, there's no need for it.
       // (We can't easily distinguish whether any object file actually
       // referenced it or not, though.)
       if (imp) {
         DefinedLocalImport *wrapimp = make<DefinedLocalImport>(
-            ctx, saver().save("__imp_" + w.wrap->getName()), d);
-        ctx.symtab.localImportChunks.push_back(wrapimp->getChunk());
+            target.ctx, saver().save("__imp_" + w.wrap->getName()), d);
+        target.symtab.localImportChunks.push_back(wrapimp->getChunk());
         map[imp] = wrapimp;
       }
     }
   }
 
   // Update pointers in input files.
-  parallelForEach(ctx.objFileInstances, [&](ObjFile *file) {
+  parallelForEach(target.ctx.objFileInstances, [&](ObjFile *file) {
     MutableArrayRef<Symbol *> syms = file->getMutableSymbols();
     for (auto &sym : syms)
       if (Symbol *s = map.lookup(sym))
diff --git a/lld/COFF/MinGW.h b/lld/COFF/MinGW.h
index aa5e53278ca4..e80f40a3a327 100644
--- a/lld/COFF/MinGW.h
+++ b/lld/COFF/MinGW.h
@@ -25,7 +25,7 @@ class COFFLinkerContext;
 // symbols for MinGW.
 class AutoExporter {
 public:
-  AutoExporter(COFFLinkerContext &ctx,
+  AutoExporter(COFFTargetContext &target,
                const llvm::DenseSet<StringRef> &manualExcludeSymbols);
 
   void addWholeArchive(StringRef path);
@@ -42,7 +42,7 @@ public:
   bool shouldExport(Defined *sym) const;
 
 private:
-  COFFLinkerContext &ctx;
+  COFFTargetContext &target;
 };
 
 void writeDefFile(StringRef name, const std::vector<Export> &exports);
@@ -61,10 +61,10 @@ struct WrappedSymbol {
   Symbol *wrap;
 };
 
-std::vector<WrappedSymbol> addWrappedSymbols(COFFLinkerContext &ctx,
+std::vector<WrappedSymbol> addWrappedSymbols(COFFTargetContext &target,
                                              llvm::opt::InputArgList &args);
 
-void wrapSymbols(COFFLinkerContext &ctx, ArrayRef<WrappedSymbol> wrapped);
+void wrapSymbols(COFFTargetContext &target, ArrayRef<WrappedSymbol> wrapped);
 
 } // namespace lld::coff
 
diff --git a/lld/COFF/PDB.cpp b/lld/COFF/PDB.cpp
index a4846624439a..9bcbdec611d9 100644
--- a/lld/COFF/PDB.cpp
+++ b/lld/COFF/PDB.cpp
@@ -1207,29 +1207,31 @@ void PDBLinker::addPublicsToPDB() {
   // Compute the public symbols.
   auto &gsiBuilder = builder.getGsiBuilder();
   std::vector<pdb::BulkPublic> publics;
-  ctx.symtab.forEachSymbol([&publics, this](Symbol *s) {
-    // Only emit external, defined, live symbols that have a chunk. Static,
-    // non-external symbols do not appear in the symbol table.
-    auto *def = dyn_cast<Defined>(s);
-    if (def && def->isLive() && def->getChunk()) {
-      // Don't emit a public symbol for coverage data symbols. LLVM code
-      // coverage (and PGO) create a __profd_ and __profc_ symbol for every
-      // function. C++ mangled names are long, and tend to dominate symbol size.
-      // Including these names triples the size of the public stream, which
-      // results in bloated PDB files. These symbols generally are not helpful
-      // for debugging, so suppress them.
-      StringRef name = def->getName();
-      if (name.data()[0] == '_' && name.data()[1] == '_') {
-        // Drop the '_' prefix for x86.
-        if (ctx.config.machine == I386)
-          name = name.drop_front(1);
-        if (name.starts_with("__profd_") || name.starts_with("__profc_") ||
-            name.starts_with("__covrec_")) {
-          return;
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    target.symtab.forEachSymbol([&publics, this](Symbol *s) {
+      // Only emit external, defined, live symbols that have a chunk. Static,
+      // non-external symbols do not appear in the symbol table.
+      auto *def = dyn_cast<Defined>(s);
+      if (def && def->isLive() && def->getChunk()) {
+        // Don't emit a public symbol for coverage data symbols. LLVM code
+        // coverage (and PGO) create a __profd_ and __profc_ symbol for every
+        // function. C++ mangled names are long, and tend to dominate symbol
+        // size. Including these names triples the size of the public stream,
+        // which results in bloated PDB files. These symbols generally are not
+        // helpful for debugging, so suppress them.
+        StringRef name = def->getName();
+        if (name.data()[0] == '_' && name.data()[1] == '_') {
+          // Drop the '_' prefix for x86.
+          if (ctx.config.machine == I386)
+            name = name.drop_front(1);
+          if (name.starts_with("__profd_") || name.starts_with("__profc_") ||
+              name.starts_with("__covrec_")) {
+            return;
+          }
         }
+        publics.push_back(createPublic(ctx, def));
       }
-      publics.push_back(createPublic(ctx, def));
-    }
+    });
   });
 
   if (!publics.empty()) {
diff --git a/lld/COFF/SymbolTable.cpp b/lld/COFF/SymbolTable.cpp
index bfb95c865880..bc97ff218d62 100644
--- a/lld/COFF/SymbolTable.cpp
+++ b/lld/COFF/SymbolTable.cpp
@@ -35,58 +35,6 @@ StringRef ltrim1(StringRef s, const char *chars) {
   return s;
 }
 
-static bool compatibleMachineType(COFFLinkerContext &ctx, MachineTypes mt) {
-  if (mt == IMAGE_FILE_MACHINE_UNKNOWN)
-    return true;
-  switch (ctx.config.machine) {
-  case ARM64:
-    return mt == ARM64 || mt == ARM64X;
-  case ARM64EC:
-    return COFF::isArm64EC(mt) || mt == AMD64;
-  case ARM64X:
-    return COFF::isAnyArm64(mt) || mt == AMD64;
-  default:
-    return ctx.config.machine == mt;
-  }
-}
-
-void SymbolTable::addFile(InputFile *file) {
-  log("Reading " + toString(file));
-  if (file->lazy) {
-    if (auto *f = dyn_cast<BitcodeFile>(file))
-      f->parseLazy();
-    else
-      cast<ObjFile>(file)->parseLazy();
-  } else {
-    file->parse();
-    if (auto *f = dyn_cast<ObjFile>(file)) {
-      ctx.objFileInstances.push_back(f);
-    } else if (auto *f = dyn_cast<BitcodeFile>(file)) {
-      if (ltoCompilationDone) {
-        error("LTO object file " + toString(file) + " linked in after "
-              "doing LTO compilation.");
-      }
-      ctx.bitcodeFileInstances.push_back(f);
-    } else if (auto *f = dyn_cast<ImportFile>(file)) {
-      ctx.importFileInstances.push_back(f);
-      if (f->chkECSym)
-        ctx.driver.pullImportThunkSymbols();
-    }
-  }
-
-  MachineTypes mt = file->getMachineType();
-  if (ctx.config.machine == IMAGE_FILE_MACHINE_UNKNOWN) {
-    ctx.config.machine = mt;
-    ctx.driver.addWinSysRootLibSearchPaths();
-  } else if (!compatibleMachineType(ctx, mt)) {
-    error(toString(file) + ": machine type " + machineToStr(mt) +
-          " conflicts with " + machineToStr(ctx.config.machine));
-    return;
-  }
-
-  ctx.driver.parseDirectives(file);
-}
-
 static void errorOrWarn(const Twine &s, bool forceUnresolved) {
   if (forceUnresolved)
     warn(s);
@@ -105,7 +53,7 @@ static void forceLazy(Symbol *s) {
   }
   case Symbol::Kind::LazyObjectKind: {
     InputFile *file = cast<LazyObject>(s)->file;
-    file->ctx.symtab.addFile(file);
+    file->ctx.addFile(file);
     break;
   }
   case Symbol::Kind::LazyDLLSymbolKind: {
@@ -292,7 +240,7 @@ void SymbolTable::loadMinGWSymbols() {
 
     StringRef name = undef->getName();
 
-    if (ctx.config.machine == I386 && ctx.config.stdcallFixup) {
+    if (target.machine == I386 && target.ctx.config.stdcallFixup) {
       // Check if we can resolve an undefined decorated symbol by finding
       // the intended target as an undecorated symbol (only with a leading
       // underscore).
@@ -313,7 +261,7 @@ void SymbolTable::loadMinGWSymbols() {
         }
         // If it's lazy or already defined, hook it up as weak alias.
         if (l->isLazy() || isa<Defined>(l)) {
-          if (ctx.config.warnStdcallFixup)
+          if (target.ctx.config.warnStdcallFixup)
             warn("Resolving " + origName + " by linking to " + newName);
           else
             log("Resolving " + origName + " by linking to " + newName);
@@ -323,7 +271,7 @@ void SymbolTable::loadMinGWSymbols() {
       }
     }
 
-    if (ctx.config.autoImport) {
+    if (target.ctx.config.autoImport) {
       if (name.starts_with("__imp_"))
         continue;
       // If we have an undefined symbol, but we have a lazy symbol we could
@@ -381,7 +329,7 @@ bool SymbolTable::handleMinGWAutomaticImport(Symbol *sym, StringRef name) {
   // for __imp_<name> instead, and drop the whole .refptr.<name> chunk.
   DefinedRegular *refptr =
       dyn_cast_or_null<DefinedRegular>(find((".refptr." + name).str()));
-  if (refptr && refptr->getChunk()->getSize() == ctx.config.wordsize) {
+  if (refptr && refptr->getChunk()->getSize() == target.ctx.config.wordsize) {
     SectionChunk *sc = dyn_cast_or_null<SectionChunk>(refptr->getChunk());
     if (sc && sc->getRelocs().size() == 1 && *sc->symbols().begin() == sym) {
       log("Replacing .refptr." + name + " with " + imp->getName());
@@ -472,12 +420,12 @@ void SymbolTable::reportUnresolvable() {
     }
     if (name.contains("_PchSym_"))
       continue;
-    if (ctx.config.autoImport && impSymbol(name))
+    if (target.ctx.config.autoImport && impSymbol(name))
       continue;
     undefs.insert(sym);
   }
 
-  reportProblemSymbols(ctx, undefs,
+  reportProblemSymbols(target.ctx, undefs,
                        /* localImports */ nullptr, true);
 }
 
@@ -486,7 +434,7 @@ void SymbolTable::resolveRemainingUndefines() {
   SmallPtrSet<Symbol *, 8> undefs;
   DenseMap<Symbol *, Symbol *> localImports;
 
-  if (isArm64EC(ctx.config.machine)) {
+  if (target.machine == ARM64EC) {
     for (auto &i : symMap) {
       auto *undef = dyn_cast<Undefined>(i.second);
       if (!undef || !undef->isUsedInRegularObj || undef->getWeakAlias())
@@ -503,8 +451,9 @@ void SymbolTable::resolveRemainingUndefines() {
         continue;
       }
 
-      auto thunk = make<ECThunkChunk>(ctx, cast<DefinedRegular>(targetSym));
-      replaceSymbol<DefinedSynthetic>(undef, name, thunk);
+      auto chunk =
+          make<ECThunkChunk>(target.ctx, cast<DefinedRegular>(targetSym));
+      replaceSymbol<DefinedSynthetic>(undef, name, chunk);
     }
   }
 
@@ -526,17 +475,17 @@ void SymbolTable::resolveRemainingUndefines() {
     // This odd rule is for compatibility with MSVC linker.
     if (name.starts_with("__imp_")) {
       StringRef impName = name.substr(strlen("__imp_"));
-      if (isArm64EC(ctx.config.machine))
+      if (target.machine == ARM64EC)
         impName.consume_front("aux_");
       Symbol *imp = find(impName);
-      if (isArm64EC(ctx.config.machine) && (!imp || !isa<Defined>(imp))) {
+      if (target.machine == ARM64EC && (!imp || !isa<Defined>(imp))) {
         if (std::optional<std::string> MangledName =
                 getArm64ECMangledFunctionName(impName))
           imp = find(*MangledName);
       }
       if (imp && isa<Defined>(imp)) {
         auto *d = cast<Defined>(imp);
-        replaceSymbol<DefinedLocalImport>(sym, ctx, name, d);
+        replaceSymbol<DefinedLocalImport>(sym, target.ctx, name, d);
         localImportChunks.push_back(cast<DefinedLocalImport>(sym)->getChunk());
         localImports[sym] = d;
         continue;
@@ -548,19 +497,20 @@ void SymbolTable::resolveRemainingUndefines() {
     if (name.contains("_PchSym_"))
       continue;
 
-    if (ctx.config.autoImport && handleMinGWAutomaticImport(sym, name))
+    if (target.ctx.config.autoImport && handleMinGWAutomaticImport(sym, name))
       continue;
 
     // Remaining undefined symbols are not fatal if /force is specified.
     // They are replaced with dummy defined symbols.
-    if (ctx.config.forceUnresolved)
-      replaceSymbol<DefinedAbsolute>(sym, ctx, name, 0);
+    if (target.ctx.config.forceUnresolved)
+      replaceSymbol<DefinedAbsolute>(sym, target.ctx, name, 0);
     undefs.insert(sym);
   }
 
   reportProblemSymbols(
-      ctx, undefs,
-      ctx.config.warnLocallyDefinedImported ? &localImports : nullptr, false);
+      target.ctx, undefs,
+      target.ctx.config.warnLocallyDefinedImported ? &localImports : nullptr,
+      false);
 }
 
 std::pair<Symbol *, bool> SymbolTable::insert(StringRef name) {
@@ -655,7 +605,7 @@ void SymbolTable::addLazyObject(InputFile *f, StringRef n) {
     return;
   s->pendingArchiveLoad = true;
   f->lazy = false;
-  addFile(f);
+  target.ctx.addFile(f);
 }
 
 void SymbolTable::addLazyDLLSymbol(DLLFile *f, DLLFile::Symbol *sym,
@@ -721,7 +671,7 @@ void SymbolTable::reportDuplicate(Symbol *existing, InputFile *newFile,
                                   uint32_t newSectionOffset) {
   std::string msg;
   llvm::raw_string_ostream os(msg);
-  os << "duplicate symbol: " << toString(ctx, *existing);
+  os << "duplicate symbol: " << toString(target.ctx, *existing);
 
   DefinedRegular *d = dyn_cast<DefinedRegular>(existing);
   if (d && isa<ObjFile>(d->getFile())) {
@@ -733,7 +683,7 @@ void SymbolTable::reportDuplicate(Symbol *existing, InputFile *newFile,
   os << getSourceLocation(newFile, newSc, newSectionOffset,
                           existing->getName());
 
-  if (ctx.config.forceMultiple)
+  if (target.ctx.config.forceMultiple)
     warn(os.str());
   else
     error(os.str());
@@ -743,7 +693,7 @@ Symbol *SymbolTable::addAbsolute(StringRef n, COFFSymbolRef sym) {
   auto [s, wasInserted] = insert(n, nullptr);
   s->isUsedInRegularObj = true;
   if (wasInserted || isa<Undefined>(s) || s->isLazy())
-    replaceSymbol<DefinedAbsolute>(s, ctx, n, sym);
+    replaceSymbol<DefinedAbsolute>(s, target.ctx, n, sym);
   else if (auto *da = dyn_cast<DefinedAbsolute>(s)) {
     if (da->getVA() != sym.getValue())
       reportDuplicate(s, nullptr);
@@ -756,7 +706,7 @@ Symbol *SymbolTable::addAbsolute(StringRef n, uint64_t va) {
   auto [s, wasInserted] = insert(n, nullptr);
   s->isUsedInRegularObj = true;
   if (wasInserted || isa<Undefined>(s) || s->isLazy())
-    replaceSymbol<DefinedAbsolute>(s, ctx, n, va);
+    replaceSymbol<DefinedAbsolute>(s, target.ctx, n, va);
   else if (auto *da = dyn_cast<DefinedAbsolute>(s)) {
     if (da->getVA() != va)
       reportDuplicate(s, nullptr);
@@ -831,7 +781,7 @@ Symbol *SymbolTable::addImportThunk(StringRef name, DefinedImportData *id,
   auto [s, wasInserted] = insert(name, nullptr);
   s->isUsedInRegularObj = true;
   if (wasInserted || isa<Undefined>(s) || s->isLazy()) {
-    replaceSymbol<DefinedImportThunk>(s, ctx, name, id, machine);
+    replaceSymbol<DefinedImportThunk>(s, target.ctx, name, id, machine);
     return s;
   }
 
@@ -844,7 +794,7 @@ DefinedImportThunk *SymbolTable::addImportCheckThunk(StringRef name,
   auto [s, wasInserted] = insert(name, nullptr);
   s->isUsedInRegularObj = true;
   if (wasInserted || isa<Undefined>(s) || s->isLazy()) {
-    replaceSymbol<DefinedImportThunk>(s, ctx, name, file->impSym,
+    replaceSymbol<DefinedImportThunk>(s, target.ctx, name, file->impSym,
                                       make<ImportThunkChunkARM64EC>(file));
     return cast<DefinedImportThunk>(s);
   }
@@ -868,21 +818,12 @@ void SymbolTable::addLibcall(StringRef name) {
   }
 }
 
-std::vector<Chunk *> SymbolTable::getChunks() const {
-  std::vector<Chunk *> res;
-  for (ObjFile *file : ctx.objFileInstances) {
-    ArrayRef<Chunk *> v = file->getChunks();
-    res.insert(res.end(), v.begin(), v.end());
-  }
-  return res;
-}
-
 Symbol *SymbolTable::find(StringRef name) const {
   return symMap.lookup(CachedHashStringRef(name));
 }
 
 Symbol *SymbolTable::findUnderscore(StringRef name) const {
-  if (ctx.config.machine == I386)
+  if (target.machine == I386)
     return find(("_" + name).str());
   return find(name);
 }
@@ -929,7 +870,7 @@ Symbol *SymbolTable::findMangle(StringRef name) {
   };
 
   // For non-x86, just look for C++ functions.
-  if (ctx.config.machine != I386)
+  if (target.machine != I386)
     return findByPrefix("?" + name + "@@Y");
 
   if (!name.starts_with("_"))
@@ -952,19 +893,18 @@ Symbol *SymbolTable::addUndefined(StringRef name) {
 }
 
 void SymbolTable::compileBitcodeFiles() {
-  ltoCompilationDone = true;
-  if (ctx.bitcodeFileInstances.empty())
+  if (target.ctx.bitcodeFileInstances.empty())
     return;
 
   llvm::TimeTraceScope timeScope("Compile bitcode");
-  ScopedTimer t(ctx.ltoTimer);
-  lto.reset(new BitcodeCompiler(ctx));
-  for (BitcodeFile *f : ctx.bitcodeFileInstances)
+  ScopedTimer t(target.ctx.ltoTimer);
+  lto.reset(new BitcodeCompiler(target.ctx));
+  for (BitcodeFile *f : target.ctx.bitcodeFileInstances)
     lto->add(*f);
   for (InputFile *newObj : lto->compile()) {
     ObjFile *obj = cast<ObjFile>(newObj);
     obj->parse();
-    ctx.objFileInstances.push_back(obj);
+    target.ctx.objFileInstances.push_back(obj);
   }
 }
 
diff --git a/lld/COFF/SymbolTable.h b/lld/COFF/SymbolTable.h
index 0d343b9131b4..f0cf5373f2cc 100644
--- a/lld/COFF/SymbolTable.h
+++ b/lld/COFF/SymbolTable.h
@@ -25,6 +25,7 @@ namespace lld::coff {
 class Chunk;
 class CommonChunk;
 class COFFLinkerContext;
+class COFFTargetContext;
 class Defined;
 class DefinedAbsolute;
 class DefinedRegular;
@@ -46,9 +47,7 @@ class Symbol;
 // There is one add* function per symbol type.
 class SymbolTable {
 public:
-  SymbolTable(COFFLinkerContext &c) : ctx(c) {}
-
-  void addFile(InputFile *file);
+  SymbolTable(COFFTargetContext &t) : target(t) {}
 
   // Emit errors for symbols that cannot be resolved.
   void reportUnresolvable();
@@ -63,9 +62,6 @@ public:
   void loadMinGWSymbols();
   bool handleMinGWAutomaticImport(Symbol *sym, StringRef name);
 
-  // Returns a list of chunks of selected symbols.
-  std::vector<Chunk *> getChunks() const;
-
   // Returns a symbol for a given name. Returns a nullptr if not found.
   Symbol *find(StringRef name) const;
   Symbol *findUnderscore(StringRef name) const;
@@ -143,11 +139,10 @@ private:
 
   llvm::DenseMap<llvm::CachedHashStringRef, Symbol *> symMap;
   std::unique_ptr<BitcodeCompiler> lto;
-  bool ltoCompilationDone = false;
   std::vector<std::pair<Symbol *, Symbol *>> entryThunks;
   llvm::DenseMap<Symbol *, Symbol *> exitThunks;
 
-  COFFLinkerContext &ctx;
+  COFFTargetContext &target;
 };
 
 std::vector<std::string> getSymbolLocations(ObjFile *file, uint32_t symIndex);
diff --git a/lld/COFF/Symbols.h b/lld/COFF/Symbols.h
index 7c24f5b56d05..a605e6e7175f 100644
--- a/lld/COFF/Symbols.h
+++ b/lld/COFF/Symbols.h
@@ -31,6 +31,7 @@ using llvm::object::coff_symbol_generic;
 
 class ArchiveFile;
 class COFFLinkerContext;
+class COFFTargetContext;
 class InputFile;
 class ObjFile;
 class SymbolTable;
@@ -375,7 +376,7 @@ public:
 
   StringRef getDLLName() { return file->dllName; }
   StringRef getExternalName() { return file->externalName; }
-  uint16_t getOrdinal() { return file->hdr->OrdinalHint; }
+  uint16_t getOrdinal() const { return file->getOrdinal(); }
 
   ImportFile *file;
   Chunk *&location;
diff --git a/lld/COFF/Writer.cpp b/lld/COFF/Writer.cpp
index 1fcaecd9ae15..06e97bb142ee 100644
--- a/lld/COFF/Writer.cpp
+++ b/lld/COFF/Writer.cpp
@@ -80,6 +80,8 @@ static_assert(sizeof(dosProgram) % 8 == 0,
 static const int dosStubSize = sizeof(dos_header) + sizeof(dosProgram);
 static_assert(dosStubSize % 8 == 0, "DOSStub size must be multiple of 8");
 
+static const uint32_t coffHeaderOffset = dosStubSize + sizeof(PEMagic);
+
 static const int numberOfDataDirectory = 16;
 
 namespace {
@@ -205,7 +207,10 @@ struct ChunkRange {
 class Writer {
 public:
   Writer(COFFLinkerContext &c)
-      : buffer(errorHandler().outputBuffer), delayIdata(c), edata(c), ctx(c) {}
+      : buffer(errorHandler().outputBuffer), delayIdata(c), ctx(c) {
+    ctx.forEachTarget(
+        [](COFFTargetContext &target) { target.edata.create(target); });
+  }
   void run();
 
 private:
@@ -246,8 +251,9 @@ private:
   void getSymbolsFromSections(ObjFile *file,
                               ArrayRef<SectionChunk *> symIdxChunks,
                               std::vector<Symbol *> &symbols);
-  void maybeAddRVATable(SymbolRVASet tableSymbols, StringRef tableSym,
-                        StringRef countSym, bool hasFlag=false);
+  void maybeAddRVATable(COFFTargetContext &target, SymbolRVASet tableSymbols,
+                        StringRef tableSym, StringRef countSym,
+                        bool hasFlag = false);
   void setSectionPermissions();
   void setECSymbols();
   void writeSections();
@@ -270,13 +276,17 @@ private:
 
   OutputSection *findSection(StringRef name);
   void addBaserels();
+  void createDynamicRelocs();
   void addBaserelBlocks(std::vector<Baserel> &v);
+  void addBaserelBlock(uint32_t page, Baserel *begin, Baserel *end);
 
   uint32_t getSizeOfInitializedData();
 
   void prepareLoadConfig();
-  template <typename T> void prepareLoadConfig(T *loadConfig);
-  template <typename T> void checkLoadConfigGuardData(const T *loadConfig);
+  template <typename T>
+  void prepareLoadConfig(COFFTargetContext &target, T *loadConfig);
+  template <typename T>
+  void checkLoadConfigGuardData(COFFTargetContext &target, const T *loadConfig);
 
   std::unique_ptr<FileOutputBuffer> &buffer;
   std::map<PartialSectionKey, PartialSection *> partialSections;
@@ -286,12 +296,9 @@ private:
   IdataContents idata;
   Chunk *importTableStart = nullptr;
   uint64_t importTableSize = 0;
-  Chunk *edataStart = nullptr;
-  Chunk *edataEnd = nullptr;
   Chunk *iatStart = nullptr;
   uint64_t iatSize = 0;
   DelayLoadContents delayIdata;
-  EdataContents edata;
   bool setNoSEHCharacteristic = false;
   uint32_t tlsAlignment = 0;
 
@@ -300,10 +307,15 @@ private:
   CVDebugRecordChunk *buildId = nullptr;
   ArrayRef<uint8_t> sectionTable;
 
+  DynamicRelocsChunk *dynamicRelocsChunk = nullptr;
+  uint32_t arm64xExceptionTableSizeReloc;
+  uint32_t arm64xExportTableSizeReloc;
+
   uint64_t fileSize;
   uint32_t pointerToSymbolTable = 0;
   uint64_t sizeOfImage;
   uint64_t sizeOfHeaders;
+  uint64_t sizeOfBaserels = 0;
 
   OutputSection *textSec;
   OutputSection *hexpthkSec;
@@ -314,6 +326,7 @@ private:
   OutputSection *idataSec;
   OutputSection *edataSec;
   OutputSection *didatSec;
+  OutputSection *a64xrmSec;
   OutputSection *rsrcSec;
   OutputSection *relocSec;
   OutputSection *ctorsSec;
@@ -594,7 +607,8 @@ void Writer::createECCodeMap() {
 
   closeRange();
 
-  Symbol *tableCountSym = ctx.symtab.findUnderscore("__hybrid_code_map_count");
+  Symbol *tableCountSym =
+      ctx.getTarget(ARM64EC).symtab.findUnderscore("__hybrid_code_map_count");
   cast<DefinedAbsolute>(tableCountSym)->setVA(codeMap.size());
 }
 
@@ -749,6 +763,7 @@ void Writer::run() {
     mergeSections();
     sortECChunks();
     appendECImportTables();
+    createDynamicRelocs();
     removeUnusedSections();
     finalizeAddresses();
     removeEmptySections();
@@ -1024,13 +1039,15 @@ void Writer::createSections() {
   idataSec = createSection(".idata", data | r);
   edataSec = createSection(".edata", data | r);
   didatSec = createSection(".didat", data | r);
+  if (isArm64EC(ctx.config.machine))
+    a64xrmSec = createSection(".a64xrm", data | r);
   rsrcSec = createSection(".rsrc", data | r);
   relocSec = createSection(".reloc", data | discardable | r);
   ctorsSec = createSection(".ctors", data | r | w);
   dtorsSec = createSection(".dtors", data | r | w);
 
   // Then bin chunks by name and output characteristics.
-  for (Chunk *c : ctx.symtab.getChunks()) {
+  for (Chunk *c : ctx.getChunks()) {
     auto *sc = dyn_cast<SectionChunk>(c);
     if (sc && !sc->live) {
       if (ctx.config.verbose)
@@ -1044,8 +1061,8 @@ void Writer::createSections() {
     if (name.starts_with(".tls"))
       tlsAlignment = std::max(tlsAlignment, c->getAlignment());
 
-    PartialSection *pSec = createPartialSection(name,
-                                                c->getOutputCharacteristics());
+    PartialSection *pSec =
+        createPartialSection(name, c->getOutputCharacteristics());
     pSec->chunks.push_back(c);
   }
 
@@ -1131,10 +1148,12 @@ void Writer::createMiscChunks() {
   }
 
   // Create thunks for locally-dllimported symbols.
-  if (!ctx.symtab.localImportChunks.empty()) {
-    for (Chunk *c : ctx.symtab.localImportChunks)
-      rdataSec->addChunk(c);
-  }
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (!target.symtab.localImportChunks.empty()) {
+      for (Chunk *c : target.symtab.localImportChunks)
+        rdataSec->addChunk(c);
+    }
+  });
 
   // Create Debug Information Chunks
   debugInfoSec = config->mingw ? buildidSec : rdataSec;
@@ -1153,9 +1172,11 @@ void Writer::createMiscChunks() {
     // if we're ultimately not going to write CodeView data to the PDB.
     buildId = make<CVDebugRecordChunk>(ctx);
     debugRecords.emplace_back(COFF::IMAGE_DEBUG_TYPE_CODEVIEW, buildId);
-    if (Symbol *buildidSym = ctx.symtab.findUnderscore("__buildid"))
-      replaceSymbol<DefinedSynthetic>(buildidSym, buildidSym->getName(),
-                                      buildId, 4);
+    ctx.forEachTarget([&](COFFTargetContext &target) {
+      if (Symbol *buildidSym = target.symtab.findUnderscore("__buildid"))
+        replaceSymbol<DefinedSynthetic>(buildidSym, buildidSym->getName(),
+                                        buildId, 4);
+    });
   }
 
   if (config->cetCompat) {
@@ -1248,8 +1269,7 @@ void Writer::appendImportThunks() {
   }
 
   if (!delayIdata.empty()) {
-    Defined *helper = cast<Defined>(ctx.config.delayLoadHelper);
-    delayIdata.create(helper);
+    delayIdata.create();
     for (Chunk *c : delayIdata.getChunks())
       didatSec->addChunk(c);
     for (Chunk *c : delayIdata.getDataChunks())
@@ -1265,23 +1285,47 @@ void Writer::appendImportThunks() {
 
 void Writer::createExportTable() {
   llvm::TimeTraceScope timeScope("Export table");
+
   if (!edataSec->chunks.empty()) {
+    if (ctx.hybridTarget) {
+      llvm::stable_sort(edataSec->chunks, [=](const Chunk *a, const Chunk *b) {
+        return (a->getMachine() != ARM64) < (b->getMachine() != ARM64);
+      });
+
+      for (auto chunk : edataSec->chunks) {
+        if (chunk->getMachine() != ARM64) {
+          ctx.hybridTarget->edataStart = chunk;
+          ctx.hybridTarget->edataEnd = edataSec->chunks.back();
+          break;
+        }
+
+        if (!ctx.primaryTarget.edataStart)
+          ctx.primaryTarget.edataStart = chunk;
+        ctx.primaryTarget.edataEnd = chunk;
+      }
+    } else {
+      ctx.primaryTarget.edataStart = edataSec->chunks.front();
+      ctx.primaryTarget.edataEnd = edataSec->chunks.back();
+    }
+  }
+  ctx.forEachTarget([&](COFFTargetContext &target) {
     // Allow using a custom built export table from input object files, instead
     // of having the linker synthesize the tables.
-    if (ctx.config.hadExplicitExports)
-      warn("literal .edata sections override exports");
-  } else if (!ctx.config.exports.empty()) {
-    for (Chunk *c : edata.chunks)
-      edataSec->addChunk(c);
-  }
-  if (!edataSec->chunks.empty()) {
-    edataStart = edataSec->chunks.front();
-    edataEnd = edataSec->chunks.back();
-  }
-  // Warn on exported deleting destructor.
-  for (auto e : ctx.config.exports)
-    if (e.sym && e.sym->getName().starts_with("??_G"))
-      warn("export of deleting dtor: " + toString(ctx, *e.sym));
+    if (target.edataStart) {
+      if (target.hadExplicitExports)
+        warn("literal .edata sections override exports");
+    } else if (!target.exports.empty()) {
+      for (Chunk *c : target.edata.chunks)
+        edataSec->addChunk(c);
+      target.edataStart = target.edata.chunks.front();
+      target.edataEnd = target.edata.chunks.back();
+    }
+
+    // Warn on exported deleting destructor.
+    for (auto e : target.exports)
+      if (e.sym && e.sym->getName().starts_with("??_G"))
+        warn("export of deleting dtor: " + toString(ctx, *e.sym));
+  });
 }
 
 void Writer::removeUnusedSections() {
@@ -1552,8 +1596,11 @@ void Writer::assignAddresses() {
 
   for (OutputSection *sec : ctx.outputSections) {
     llvm::TimeTraceScope timeScope("Section: ", sec->name);
-    if (sec == relocSec)
+    if (sec == relocSec) {
       addBaserels();
+      if (dynamicRelocsChunk)
+        relocSec->addChunk(dynamicRelocsChunk);
+    }
     uint64_t rawSize = 0, virtualSize = 0;
     sec->header.VirtualAddress = rva;
 
@@ -1607,6 +1654,7 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
   // When run under Windows, the loader looks at AddressOfNewExeHeader and uses
   // the PE header instead.
   Configuration *config = &ctx.config;
+  COFFTargetContext &target = ctx.primaryTarget;
   uint8_t *buf = buffer->getBufferStart();
   auto *dos = reinterpret_cast<dos_header *>(buf);
   buf += sizeof(dos_header);
@@ -1630,16 +1678,7 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
   // Write COFF header
   auto *coff = reinterpret_cast<coff_file_header *>(buf);
   buf += sizeof(*coff);
-  switch (config->machine) {
-  case ARM64EC:
-    coff->Machine = AMD64;
-    break;
-  case ARM64X:
-    coff->Machine = ARM64;
-    break;
-  default:
-    coff->Machine = config->machine;
-  }
+  coff->Machine = target.machine == ARM64EC ? AMD64 : target.machine;
   coff->NumberOfSections = ctx.outputSections.size();
   coff->Characteristics = IMAGE_FILE_EXECUTABLE_IMAGE;
   if (config->largeAddressAware)
@@ -1685,7 +1724,7 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
   pe->SizeOfImage = sizeOfImage;
   pe->SizeOfHeaders = sizeOfHeaders;
   if (!config->noEntry) {
-    Defined *entry = cast<Defined>(config->entry);
+    Defined *entry = cast<Defined>(target.entry);
     pe->AddressOfEntryPoint = entry->getRVA();
     // Pointer to thumb code must have the LSB set, so adjust it.
     if (config->machine == ARMNT)
@@ -1727,10 +1766,11 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
   // Write data directory
   auto *dir = reinterpret_cast<data_directory *>(buf);
   buf += sizeof(*dir) * numberOfDataDirectory;
-  if (edataStart) {
-    dir[EXPORT_TABLE].RelativeVirtualAddress = edataStart->getRVA();
-    dir[EXPORT_TABLE].Size =
-        edataEnd->getRVA() + edataEnd->getSize() - edataStart->getRVA();
+  if (target.edataStart) {
+    dir[EXPORT_TABLE].RelativeVirtualAddress = target.edataStart->getRVA();
+    dir[EXPORT_TABLE].Size = target.edataEnd->getRVA() +
+                             target.edataEnd->getSize() -
+                             target.edataStart->getRVA();
   }
   if (importTableStart) {
     dir[IMPORT_TABLE].RelativeVirtualAddress = importTableStart->getRVA();
@@ -1754,11 +1794,11 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
                                 exceptionTable.last->getSize() -
                                 exceptionTable.first->getRVA();
   }
-  if (relocSec->getVirtualSize()) {
+  if (sizeOfBaserels) {
     dir[BASE_RELOCATION_TABLE].RelativeVirtualAddress = relocSec->getRVA();
-    dir[BASE_RELOCATION_TABLE].Size = relocSec->getVirtualSize();
+    dir[BASE_RELOCATION_TABLE].Size = sizeOfBaserels;
   }
-  if (Symbol *sym = ctx.symtab.findUnderscore("_tls_used")) {
+  if (Symbol *sym = target.symtab.findUnderscore("_tls_used")) {
     if (Defined *b = dyn_cast<Defined>(sym)) {
       dir[TLS_TABLE].RelativeVirtualAddress = b->getRVA();
       dir[TLS_TABLE].Size = config->is64()
@@ -1770,7 +1810,7 @@ template <typename PEHeaderTy> void Writer::writeHeader() {
     dir[DEBUG_DIRECTORY].RelativeVirtualAddress = debugDirectory->getRVA();
     dir[DEBUG_DIRECTORY].Size = debugDirectory->getSize();
   }
-  if (Symbol *sym = ctx.symtab.findUnderscore("_load_config_used")) {
+  if (Symbol *sym = target.symtab.findUnderscore("_load_config_used")) {
     if (auto *b = dyn_cast<DefinedRegular>(sym)) {
       SectionChunk *sc = b->getChunk();
       assert(b->getRVA() >= sc->getRVA());
@@ -1836,10 +1876,11 @@ void Writer::createSEHTable() {
   // Set the "no SEH" characteristic if there really were no handlers, or if
   // there is no load config object to point to the table of handlers.
   setNoSEHCharacteristic =
-      handlers.empty() || !ctx.symtab.findUnderscore("_load_config_used");
+      handlers.empty() ||
+      !ctx.primaryTarget.symtab.findUnderscore("_load_config_used");
 
-  maybeAddRVATable(std::move(handlers), "__safe_se_handler_table",
-                   "__safe_se_handler_count");
+  maybeAddRVATable(ctx.primaryTarget, std::move(handlers),
+                   "__safe_se_handler_table", "__safe_se_handler_count");
 }
 
 // Add a symbol to an RVA set. Two symbols may have the same RVA, but an RVA set
@@ -1936,7 +1977,8 @@ void Writer::createGuardCFTables() {
 
   if (config->guardCF == GuardCFLevel::Off) {
     if (isArm64EC(config->machine)) {
-      Symbol *flagSym = ctx.symtab.findUnderscore("__guard_flags");
+      Symbol *flagSym =
+          ctx.getTarget(ARM64EC).symtab.findUnderscore("__guard_flags");
       cast<DefinedAbsolute>(flagSym)->setVA(
           uint32_t(GuardFlags::CF_INSTRUMENTED));
     }
@@ -1969,12 +2011,16 @@ void Writer::createGuardCFTables() {
   }
 
   // Mark the image entry as address-taken.
-  if (config->entry)
-    maybeAddAddressTakenFunction(addressTakenSyms, config->entry);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (target.entry)
+      maybeAddAddressTakenFunction(addressTakenSyms, target.entry);
+  });
 
   // Mark exported symbols in executable sections as address-taken.
-  for (Export &e : config->exports)
-    maybeAddAddressTakenFunction(addressTakenSyms, e.sym);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    for (Export &e : target.exports)
+      maybeAddAddressTakenFunction(addressTakenSyms, e.sym);
+  });
 
   // For each entry in the .giats table, check if it has a corresponding load
   // thunk (e.g. because the DLL that defines it will be delay-loaded) and, if
@@ -1991,33 +2037,35 @@ void Writer::createGuardCFTables() {
     if (c.inputChunk->getAlignment() < 16)
       c.inputChunk->setAlignment(16);
 
-  maybeAddRVATable(std::move(addressTakenSyms), "__guard_fids_table",
-                   "__guard_fids_count");
-
-  // Add the Guard Address Taken IAT Entry Table (.giats).
-  maybeAddRVATable(std::move(giatsRVASet), "__guard_iat_table",
-                   "__guard_iat_count");
-
-  // Add the longjmp target table unless the user told us not to.
-  if (config->guardCF & GuardCFLevel::LongJmp)
-    maybeAddRVATable(std::move(longJmpTargets), "__guard_longjmp_table",
-                     "__guard_longjmp_count");
-
-  // Add the ehcont target table unless the user told us not to.
-  if (config->guardCF & GuardCFLevel::EHCont)
-    maybeAddRVATable(std::move(ehContTargets), "__guard_eh_cont_table",
-                     "__guard_eh_cont_count");
-
-  // Set __guard_flags, which will be used in the load config to indicate that
-  // /guard:cf was enabled.
-  uint32_t guardFlags = uint32_t(GuardFlags::CF_INSTRUMENTED) |
-                        uint32_t(GuardFlags::CF_FUNCTION_TABLE_PRESENT);
-  if (config->guardCF & GuardCFLevel::LongJmp)
-    guardFlags |= uint32_t(GuardFlags::CF_LONGJUMP_TABLE_PRESENT);
-  if (config->guardCF & GuardCFLevel::EHCont)
-    guardFlags |= uint32_t(GuardFlags::EH_CONTINUATION_TABLE_PRESENT);
-  Symbol *flagSym = ctx.symtab.findUnderscore("__guard_flags");
-  cast<DefinedAbsolute>(flagSym)->setVA(guardFlags);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    maybeAddRVATable(target, std::move(addressTakenSyms), "__guard_fids_table",
+                     "__guard_fids_count");
+
+    // Add the Guard Address Taken IAT Entry Table (.giats).
+    maybeAddRVATable(target, std::move(giatsRVASet), "__guard_iat_table",
+                     "__guard_iat_count");
+
+    // Add the longjmp target table unless the user told us not to.
+    if (config->guardCF & GuardCFLevel::LongJmp)
+      maybeAddRVATable(target, std::move(longJmpTargets),
+                       "__guard_longjmp_table", "__guard_longjmp_count");
+
+    // Add the ehcont target table unless the user told us not to.
+    if (config->guardCF & GuardCFLevel::EHCont)
+      maybeAddRVATable(target, std::move(ehContTargets),
+                       "__guard_eh_cont_table", "__guard_eh_cont_count");
+
+    // Set __guard_flags, which will be used in the load config to indicate that
+    // /guard:cf was enabled.
+    uint32_t guardFlags = uint32_t(GuardFlags::CF_INSTRUMENTED) |
+                          uint32_t(GuardFlags::CF_FUNCTION_TABLE_PRESENT);
+    if (config->guardCF & GuardCFLevel::LongJmp)
+      guardFlags |= uint32_t(GuardFlags::CF_LONGJUMP_TABLE_PRESENT);
+    if (config->guardCF & GuardCFLevel::EHCont)
+      guardFlags |= uint32_t(GuardFlags::EH_CONTINUATION_TABLE_PRESENT);
+    Symbol *flagSym = target.symtab.findUnderscore("__guard_flags");
+    cast<DefinedAbsolute>(flagSym)->setVA(guardFlags);
+  });
 }
 
 // Take a list of input sections containing symbol table indices and add those
@@ -2076,7 +2124,8 @@ void Writer::markSymbolsForRVATable(ObjFile *file,
 // Replace the absolute table symbol with a synthetic symbol pointing to
 // tableChunk so that we can emit base relocations for it and resolve section
 // relative relocations.
-void Writer::maybeAddRVATable(SymbolRVASet tableSymbols, StringRef tableSym,
+void Writer::maybeAddRVATable(COFFTargetContext &target,
+                              SymbolRVASet tableSymbols, StringRef tableSym,
                               StringRef countSym, bool hasFlag) {
   if (tableSymbols.empty())
     return;
@@ -2088,15 +2137,17 @@ void Writer::maybeAddRVATable(SymbolRVASet tableSymbols, StringRef tableSym,
     tableChunk = make<RVATableChunk>(std::move(tableSymbols));
   rdataSec->addChunk(tableChunk);
 
-  Symbol *t = ctx.symtab.findUnderscore(tableSym);
-  Symbol *c = ctx.symtab.findUnderscore(countSym);
+  Symbol *t = target.symtab.findUnderscore(tableSym);
+  Symbol *c = target.symtab.findUnderscore(countSym);
   replaceSymbol<DefinedSynthetic>(t, t->getName(), tableChunk);
   cast<DefinedAbsolute>(c)->setVA(tableChunk->getSize() / (hasFlag ? 5 : 4));
 }
 
 // Create CHPE metadata chunks.
 void Writer::createECChunks() {
-  ctx.symtab.forEachSymbol([&](Symbol *s) {
+  COFFTargetContext &target = ctx.getTarget(ARM64EC);
+
+  target.symtab.forEachSymbol([&](Symbol *s) {
     auto sym = dyn_cast<Defined>(s);
     if (!sym || !sym->getName().starts_with("EXP+"))
       return;
@@ -2110,7 +2161,7 @@ void Writer::createECChunks() {
         warn(def->getName() + " is not a COMDAT symbol");
         return;
       }
-      Defined *t = dyn_cast_or_null<Defined>(ctx.symtab.find(
+      Defined *t = dyn_cast_or_null<Defined>(target.symtab.find(
           toString(sym->getName().substr(strlen("EXP+")) + "$hp_target")));
       if (!t || !isArm64EC(t->getChunk()->getMachine()))
         return;
@@ -2120,20 +2171,20 @@ void Writer::createECChunks() {
 
   auto codeMapChunk = make<ECCodeMapChunk>(codeMap);
   rdataSec->addChunk(codeMapChunk);
-  Symbol *codeMapSym = ctx.symtab.findUnderscore("__hybrid_code_map");
+  Symbol *codeMapSym = target.symtab.findUnderscore("__hybrid_code_map");
   replaceSymbol<DefinedSynthetic>(codeMapSym, codeMapSym->getName(),
                                   codeMapChunk);
 
   ECCodeRangesChunk *ranges = make<ECCodeRangesChunk>(ctx);
   rdataSec->addChunk(ranges);
   Symbol *rangesSym =
-      ctx.symtab.findUnderscore("__x64_code_ranges_to_entry_points");
+      target.symtab.findUnderscore("__x64_code_ranges_to_entry_points");
   replaceSymbol<DefinedSynthetic>(rangesSym, rangesSym->getName(), ranges);
 
   ECEntryPointsChunk *entryPoints = make<ECEntryPointsChunk>(ctx);
-  rdataSec->addChunk(entryPoints);
+  a64xrmSec->addChunk(entryPoints);
   Symbol *entryPointsSym =
-      ctx.symtab.findUnderscore("__arm64x_redirection_metadata");
+      target.symtab.findUnderscore("__arm64x_redirection_metadata");
   replaceSymbol<DefinedSynthetic>(entryPointsSym, entryPointsSym->getName(),
                                   entryPoints);
 }
@@ -2145,7 +2196,7 @@ void Writer::createECChunks() {
 void Writer::createRuntimePseudoRelocs() {
   std::vector<RuntimePseudoReloc> rels;
 
-  for (Chunk *c : ctx.symtab.getChunks()) {
+  for (Chunk *c : ctx.getChunks()) {
     auto *sc = dyn_cast<SectionChunk>(c);
     if (!sc || !sc->live)
       continue;
@@ -2165,26 +2216,29 @@ void Writer::createRuntimePseudoRelocs() {
     return;
   }
 
-  if (!rels.empty()) {
-    log("Writing " + Twine(rels.size()) + " runtime pseudo relocations");
-    const char *symbolName = "_pei386_runtime_relocator";
-    Symbol *relocator = ctx.symtab.findUnderscore(symbolName);
-    if (!relocator)
-      error("output image has runtime pseudo relocations, but the function " +
-            Twine(symbolName) +
-            " is missing; it is needed for fixing the relocations at runtime");
-  }
-
-  PseudoRelocTableChunk *table = make<PseudoRelocTableChunk>(rels);
-  rdataSec->addChunk(table);
-  EmptyChunk *endOfList = make<EmptyChunk>();
-  rdataSec->addChunk(endOfList);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    if (!rels.empty()) {
+      log("Writing " + Twine(rels.size()) + " runtime pseudo relocations");
+      const char *symbolName = "_pei386_runtime_relocator";
+      Symbol *relocator = target.symtab.findUnderscore(symbolName);
+      if (!relocator)
+        error("output image has runtime pseudo relocations, but the function " +
+              Twine(symbolName) +
+              " is missing; it is needed for fixing the relocations at runtime");
+    }
 
-  Symbol *headSym = ctx.symtab.findUnderscore("__RUNTIME_PSEUDO_RELOC_LIST__");
-  Symbol *endSym =
-      ctx.symtab.findUnderscore("__RUNTIME_PSEUDO_RELOC_LIST_END__");
-  replaceSymbol<DefinedSynthetic>(headSym, headSym->getName(), table);
-  replaceSymbol<DefinedSynthetic>(endSym, endSym->getName(), endOfList);
+    PseudoRelocTableChunk *table = make<PseudoRelocTableChunk>(rels);
+    rdataSec->addChunk(table);
+    EmptyChunk *endOfList = make<EmptyChunk>();
+    rdataSec->addChunk(endOfList);
+
+    Symbol *headSym =
+        target.symtab.findUnderscore("__RUNTIME_PSEUDO_RELOC_LIST__");
+    Symbol *endSym =
+        target.symtab.findUnderscore("__RUNTIME_PSEUDO_RELOC_LIST_END__");
+    replaceSymbol<DefinedSynthetic>(headSym, headSym->getName(), table);
+    replaceSymbol<DefinedSynthetic>(endSym, endSym->getName(), endOfList);
+  });
 }
 
 // MinGW specific.
@@ -2193,21 +2247,23 @@ void Writer::createRuntimePseudoRelocs() {
 // There's a symbol pointing to the start sentinel pointer, __CTOR_LIST__
 // and __DTOR_LIST__ respectively.
 void Writer::insertCtorDtorSymbols() {
-  AbsolutePointerChunk *ctorListHead = make<AbsolutePointerChunk>(ctx, -1);
-  AbsolutePointerChunk *ctorListEnd = make<AbsolutePointerChunk>(ctx, 0);
-  AbsolutePointerChunk *dtorListHead = make<AbsolutePointerChunk>(ctx, -1);
-  AbsolutePointerChunk *dtorListEnd = make<AbsolutePointerChunk>(ctx, 0);
-  ctorsSec->insertChunkAtStart(ctorListHead);
-  ctorsSec->addChunk(ctorListEnd);
-  dtorsSec->insertChunkAtStart(dtorListHead);
-  dtorsSec->addChunk(dtorListEnd);
-
-  Symbol *ctorListSym = ctx.symtab.findUnderscore("__CTOR_LIST__");
-  Symbol *dtorListSym = ctx.symtab.findUnderscore("__DTOR_LIST__");
-  replaceSymbol<DefinedSynthetic>(ctorListSym, ctorListSym->getName(),
-                                  ctorListHead);
-  replaceSymbol<DefinedSynthetic>(dtorListSym, dtorListSym->getName(),
-                                  dtorListHead);
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    AbsolutePointerChunk *ctorListHead = make<AbsolutePointerChunk>(ctx, -1);
+    AbsolutePointerChunk *ctorListEnd = make<AbsolutePointerChunk>(ctx, 0);
+    AbsolutePointerChunk *dtorListHead = make<AbsolutePointerChunk>(ctx, -1);
+    AbsolutePointerChunk *dtorListEnd = make<AbsolutePointerChunk>(ctx, 0);
+    ctorsSec->insertChunkAtStart(ctorListHead);
+    ctorsSec->addChunk(ctorListEnd);
+    dtorsSec->insertChunkAtStart(dtorListHead);
+    dtorsSec->addChunk(dtorListEnd);
+
+    Symbol *ctorListSym = target.symtab.findUnderscore("__CTOR_LIST__");
+    Symbol *dtorListSym = target.symtab.findUnderscore("__DTOR_LIST__");
+    replaceSymbol<DefinedSynthetic>(ctorListSym, ctorListSym->getName(),
+                                    ctorListHead);
+    replaceSymbol<DefinedSynthetic>(dtorListSym, dtorListSym->getName(),
+                                    dtorListHead);
+  });
 }
 
 // Handles /section options to allow users to overwrite
@@ -2233,38 +2289,66 @@ void Writer::setECSymbols() {
     return a.first->getRVA() < b.first->getRVA();
   });
 
-  Symbol *rfeTableSym = ctx.symtab.findUnderscore("__arm64x_extra_rfe_table");
+  COFFTargetContext &target = ctx.getTarget(ARM64EC);
+
+  Symbol *rfeTableSym =
+      target.symtab.findUnderscore("__arm64x_extra_rfe_table");
   replaceSymbol<DefinedSynthetic>(rfeTableSym, "__arm64x_extra_rfe_table",
                                   pdata.first);
 
   if (pdata.first) {
     Symbol *rfeSizeSym =
-        ctx.symtab.findUnderscore("__arm64x_extra_rfe_table_size");
+        target.symtab.findUnderscore("__arm64x_extra_rfe_table_size");
     cast<DefinedAbsolute>(rfeSizeSym)
         ->setVA(pdata.last->getRVA() + pdata.last->getSize() -
                 pdata.first->getRVA());
   }
 
   Symbol *rangesCountSym =
-      ctx.symtab.findUnderscore("__x64_code_ranges_to_entry_points_count");
+      target.symtab.findUnderscore("__x64_code_ranges_to_entry_points_count");
   cast<DefinedAbsolute>(rangesCountSym)->setVA(ctx.ECThunks.size());
 
   Symbol *entryPointCountSym =
-      ctx.symtab.findUnderscore("__arm64x_redirection_metadata_count");
+      target.symtab.findUnderscore("__arm64x_redirection_metadata_count");
   cast<DefinedAbsolute>(entryPointCountSym)->setVA(ctx.ECThunks.size());
 
-  Symbol *iatSym = ctx.symtab.findUnderscore("__hybrid_auxiliary_iat");
+  Symbol *iatSym = target.symtab.findUnderscore("__hybrid_auxiliary_iat");
   replaceSymbol<DefinedSynthetic>(iatSym, "__hybrid_auxiliary_iat",
                                   idata.auxIat.empty() ? nullptr
                                                        : idata.auxIat.front());
 
-  Symbol *iatCopySym = ctx.symtab.findUnderscore("__hybrid_auxiliary_iat_copy");
+  Symbol *iatCopySym =
+      target.symtab.findUnderscore("__hybrid_auxiliary_iat_copy");
   replaceSymbol<DefinedSynthetic>(iatCopySym, "__hybrid_auxiliary_iat_copy",
                                   idata.auxIatCopy.empty() ? nullptr
                                                            : idata.auxIatCopy.front());
 
-  Symbol *sym = ctx.symtab.findUnderscore("__arm64x_native_entrypoint");
-  cast<DefinedAbsolute>(sym)->setVA(ctx.config.imageBase);
+  Symbol *sym = target.symtab.findUnderscore("__arm64x_native_entrypoint");
+  uint32_t altEntry = 0;
+  if (ctx.hybridTarget && ctx.hybridTarget->entry) {
+    auto altEntrySym = dyn_cast<Defined>(ctx.hybridTarget->entry);
+    if (altEntrySym) {
+      Chunk *chunk = altEntrySym->getChunk();
+      if (auto thunkChunk = dyn_cast<ECThunkChunk>(chunk))
+        altEntrySym = thunkChunk->target;
+    }
+    if (altEntrySym)
+      altEntry = altEntrySym->getRVA();
+  }
+  cast<DefinedAbsolute>(sym)->setVA(ctx.config.imageBase + altEntry);
+
+  if (!ctx.hybridTarget)
+    return;
+
+  if (ctx.hybridTarget->edataStart)
+    ctx.arm64xRelocs[arm64xExportTableSizeReloc].setValue(
+        ctx.hybridTarget->edataEnd->getRVA() -
+        ctx.hybridTarget->edataStart->getRVA() +
+        ctx.hybridTarget->edataEnd->getSize());
+  if (hybridPdata.first)
+    ctx.arm64xRelocs[arm64xExceptionTableSizeReloc].setValue(
+        hybridPdata.last->getRVA() - hybridPdata.first->getRVA() +
+        hybridPdata.last->getSize());
 }
 
 // Write section contents to a mmap'ed file.
@@ -2456,14 +2540,30 @@ void Writer::addBaserels() {
   if (!ctx.config.relocatable)
     return;
   relocSec->chunks.clear();
+
+  Chunk *loadConfigChunk = nullptr;
+  Defined *loadConfigSym;
+  if (ctx.config.machine == ARM64X &&
+      ctx.hybridTarget->symtab.findUnderscore("_load_config_used")) {
+    Symbol *sym = ctx.primaryTarget.symtab.findUnderscore("_load_config_used");
+    if (sym && (loadConfigSym = dyn_cast<Defined>(sym)))
+      loadConfigChunk = loadConfigSym->getChunk();
+  }
+
   std::vector<Baserel> v;
   for (OutputSection *sec : ctx.outputSections) {
     if (sec->header.Characteristics & IMAGE_SCN_MEM_DISCARDABLE)
       continue;
     llvm::TimeTraceScope timeScope("Base relocations: ", sec->name);
     // Collect all locations for base relocations.
-    for (Chunk *c : sec->chunks)
+    for (Chunk *c : sec->chunks) {
       c->getBaserels(&v);
+      if (c == loadConfigChunk)
+        v.emplace_back(
+            loadConfigSym->getRVA() +
+                offsetof(coff_load_configuration64, CHPEMetadataPointer),
+            ctx.config.machine);
+    }
     // Add the addresses to .reloc section.
     if (!v.empty())
       addBaserelBlocks(v);
@@ -2480,13 +2580,121 @@ void Writer::addBaserelBlocks(std::vector<Baserel> &v) {
     uint32_t p = v[j].rva & mask;
     if (p == page)
       continue;
-    relocSec->addChunk(make<BaserelChunk>(page, &v[i], &v[0] + j));
+    addBaserelBlock(page, &v[i], &v[0] + j);
     i = j;
     page = p;
   }
   if (i == j)
     return;
-  relocSec->addChunk(make<BaserelChunk>(page, &v[i], &v[0] + j));
+  addBaserelBlock(page, &v[i], &v[0] + j);
+}
+
+void Writer::addBaserelBlock(uint32_t page, Baserel *begin, Baserel *end) {
+  auto chunk = make<BaserelChunk>(page, begin, end);
+  relocSec->addChunk(chunk);
+  sizeOfBaserels += chunk->getSize();
+}
+
+void Writer::createDynamicRelocs() {
+  if (ctx.config.machine != ARM64X)
+    return;
+
+  ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                     coffHeaderOffset + offsetof(coff_file_header, Machine),
+                     nullptr, nullptr, AMD64, sizeof(uint16_t));
+
+  const uint32_t peHeaderOffset = coffHeaderOffset + sizeof(coff_file_header);
+  const uint32_t dataDirOffset = peHeaderOffset + sizeof(pe32plus_header);
+
+  if (ctx.primaryTarget.entry || ctx.hybridTarget->entry) {
+    Defined *entrySym = ctx.hybridTarget->entry
+                            ? dyn_cast<Defined>(ctx.hybridTarget->entry)
+                            : nullptr;
+    ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                       peHeaderOffset +
+                           offsetof(pe32plus_header, AddressOfEntryPoint),
+                       entrySym, nullptr, 0, sizeof(uint32_t));
+  }
+
+  if (ctx.primaryTarget.edataStart || ctx.hybridTarget->edataStart) {
+    ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                       dataDirOffset + EXPORT_TABLE * sizeof(data_directory) +
+                           offsetof(data_directory, RelativeVirtualAddress),
+                       nullptr, ctx.hybridTarget->edataStart, 0,
+                       sizeof(uint32_t));
+    arm64xExportTableSizeReloc = ctx.arm64xRelocs.size();
+    ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                       dataDirOffset + EXPORT_TABLE * sizeof(data_directory) +
+                           offsetof(data_directory, Size),
+                       nullptr, nullptr, 0, sizeof(uint32_t));
+  }
+
+  // FIXME: RELOC_TABLE ?
+  // FIXME: DEBUG_DIRECTORY ?
+
+  if (pdata.first || hybridPdata.first) {
+    ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                       dataDirOffset +
+                           EXCEPTION_TABLE * sizeof(data_directory) +
+                           offsetof(data_directory, RelativeVirtualAddress),
+                       nullptr, hybridPdata.first, 0, sizeof(uint32_t));
+    arm64xExceptionTableSizeReloc = ctx.arm64xRelocs.size();
+    ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                       dataDirOffset +
+                           EXCEPTION_TABLE * sizeof(data_directory) +
+                           offsetof(data_directory, Size),
+                       nullptr, nullptr, 0, sizeof(uint32_t));
+  }
+
+  Chunk *loadConfigChunk = nullptr;
+  uint32_t loadConfigSize = 0, loadConfigOffset = 0;
+
+  if (Symbol *sym =
+          ctx.hybridTarget->symtab.findUnderscore("_load_config_used")) {
+    if (auto *b = dyn_cast<DefinedRegular>(sym)) {
+      SectionChunk *chunk = b->getChunk();
+      assert(b->getRVA() >= chunk->getRVA());
+      loadConfigOffset = b->getValue();
+      if (!chunk->hasData || loadConfigOffset + 4 > chunk->getSize())
+        fatal("_load_config_used is malformed");
+
+      ArrayRef<uint8_t> secContents = chunk->getContents();
+      loadConfigSize = *reinterpret_cast<const ulittle32_t *>(
+          &secContents[loadConfigOffset]);
+      if (loadConfigOffset + loadConfigSize > chunk->getSize())
+        fatal("_load_config_used is too large");
+      loadConfigChunk = chunk;
+    }
+  }
+
+  ctx.addArm64XReloc(
+      IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+      dataDirOffset + LOAD_CONFIG_TABLE * sizeof(data_directory) +
+          offsetof(data_directory, RelativeVirtualAddress),
+      nullptr, loadConfigChunk, loadConfigOffset, sizeof(uint32_t));
+  ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, nullptr, nullptr,
+                     dataDirOffset +
+                         LOAD_CONFIG_TABLE * sizeof(data_directory) +
+                         offsetof(data_directory, Size),
+                     nullptr, nullptr, loadConfigSize, sizeof(uint32_t));
+
+  if (loadConfigChunk && (ctx.primaryTarget.entry || ctx.hybridTarget->entry)) {
+    Symbol *s = ctx.hybridTarget->symtab.findUnderscore("__chpe_metadata");
+    if (auto sym = dyn_cast<DefinedRegular>(s)) {
+      Defined *entry = ctx.primaryTarget.entry
+                           ? dyn_cast<Defined>(ctx.primaryTarget.entry)
+                           : nullptr;
+      ctx.addArm64XReloc(IMAGE_DVRT_ARM64X_FIXUP_TYPE_VALUE, sym, nullptr,
+                         offsetof(chpe_metadata, AlternateEntryPoint), entry,
+                         nullptr, 0, sizeof(uint32_t));
+    }
+  }
+
+  if (Symbol *sym =
+          ctx.hybridTarget->symtab.findUnderscore("_load_config_used")) {
+  }
+
+  dynamicRelocsChunk = make<DynamicRelocsChunk>(ctx.arm64xRelocs);
 }
 
 PartialSection *Writer::createPartialSection(StringRef name,
@@ -2506,73 +2714,108 @@ PartialSection *Writer::findPartialSection(StringRef name, uint32_t outChars) {
 }
 
 void Writer::fixTlsAlignment() {
-  Defined *tlsSym =
-      dyn_cast_or_null<Defined>(ctx.symtab.findUnderscore("_tls_used"));
-  if (!tlsSym)
-    return;
+  ctx.forEachTarget([&](COFFTargetContext &target) {
+    Defined *tlsSym =
+        dyn_cast_or_null<Defined>(target.symtab.findUnderscore("_tls_used"));
+    if (!tlsSym)
+      return;
 
-  OutputSection *sec = ctx.getOutputSection(tlsSym->getChunk());
-  assert(sec && tlsSym->getRVA() >= sec->getRVA() &&
-         "no output section for _tls_used");
+    OutputSection *sec = ctx.getOutputSection(tlsSym->getChunk());
+    assert(sec && tlsSym->getRVA() >= sec->getRVA() &&
+           "no output section for _tls_used");
 
-  uint8_t *secBuf = buffer->getBufferStart() + sec->getFileOff();
-  uint64_t tlsOffset = tlsSym->getRVA() - sec->getRVA();
-  uint64_t directorySize = ctx.config.is64()
-                               ? sizeof(object::coff_tls_directory64)
-                               : sizeof(object::coff_tls_directory32);
+    uint8_t *secBuf = buffer->getBufferStart() + sec->getFileOff();
+    uint64_t tlsOffset = tlsSym->getRVA() - sec->getRVA();
+    uint64_t directorySize = ctx.config.is64()
+                                 ? sizeof(object::coff_tls_directory64)
+                                 : sizeof(object::coff_tls_directory32);
 
-  if (tlsOffset + directorySize > sec->getRawSize())
-    fatal("_tls_used sym is malformed");
+    if (tlsOffset + directorySize > sec->getRawSize())
+      fatal("_tls_used sym is malformed");
 
-  if (ctx.config.is64()) {
-    object::coff_tls_directory64 *tlsDir =
-        reinterpret_cast<object::coff_tls_directory64 *>(&secBuf[tlsOffset]);
-    tlsDir->setAlignment(tlsAlignment);
-  } else {
-    object::coff_tls_directory32 *tlsDir =
-        reinterpret_cast<object::coff_tls_directory32 *>(&secBuf[tlsOffset]);
-    tlsDir->setAlignment(tlsAlignment);
-  }
+    if (ctx.config.is64()) {
+      object::coff_tls_directory64 *tlsDir =
+          reinterpret_cast<object::coff_tls_directory64 *>(&secBuf[tlsOffset]);
+      tlsDir->setAlignment(tlsAlignment);
+    } else {
+      object::coff_tls_directory32 *tlsDir =
+          reinterpret_cast<object::coff_tls_directory32 *>(&secBuf[tlsOffset]);
+      tlsDir->setAlignment(tlsAlignment);
+    }
+  });
 }
 
 void Writer::prepareLoadConfig() {
-  Symbol *sym = ctx.symtab.findUnderscore("_load_config_used");
-  auto *b = cast_if_present<DefinedRegular>(sym);
-  if (!b) {
+  auto getLoadConfigBuffer = [&](COFFTargetContext &target) -> void * {
+    Symbol *sym = target.symtab.findUnderscore("_load_config_used");
+    auto *b = cast_if_present<DefinedRegular>(sym);
+    if (!b)
+      return nullptr;
+
+    OutputSection *sec = ctx.getOutputSection(b->getChunk());
+    uint8_t *buf = buffer->getBufferStart();
+    uint8_t *secBuf = buf + sec->getFileOff();
+    uint8_t *symBuf = secBuf + (b->getRVA() - sec->getRVA());
+    uint32_t expectedAlign = ctx.config.is64() ? 8 : 4;
+    if (b->getChunk()->getAlignment() < expectedAlign)
+      warn("'_load_config_used' is misaligned (expected alignment to be " +
+           Twine(expectedAlign) + " bytes, got " +
+           Twine(b->getChunk()->getAlignment()) + " instead)");
+    else if (!isAligned(Align(expectedAlign), b->getRVA()))
+      warn("'_load_config_used' is misaligned (RVA is 0x" +
+           Twine::utohexstr(b->getRVA()) + " not aligned to " +
+           Twine(expectedAlign) + " bytes)");
+    return symBuf;
+  };
+
+  void *loadConfigBuf = getLoadConfigBuffer(ctx.primaryTarget);
+  if (!loadConfigBuf) {
     if (ctx.config.guardCF != GuardCFLevel::Off)
       warn("Control Flow Guard is enabled but '_load_config_used' is missing");
     return;
   }
 
-  OutputSection *sec = ctx.getOutputSection(b->getChunk());
-  uint8_t *buf = buffer->getBufferStart();
-  uint8_t *secBuf = buf + sec->getFileOff();
-  uint8_t *symBuf = secBuf + (b->getRVA() - sec->getRVA());
-  uint32_t expectedAlign = ctx.config.is64() ? 8 : 4;
-  if (b->getChunk()->getAlignment() < expectedAlign)
-    warn("'_load_config_used' is misaligned (expected alignment to be " +
-         Twine(expectedAlign) + " bytes, got " +
-         Twine(b->getChunk()->getAlignment()) + " instead)");
-  else if (!isAligned(Align(expectedAlign), b->getRVA()))
-    warn("'_load_config_used' is misaligned (RVA is 0x" +
-         Twine::utohexstr(b->getRVA()) + " not aligned to " +
-         Twine(expectedAlign) + " bytes)");
-
   if (ctx.config.is64())
-    prepareLoadConfig(reinterpret_cast<coff_load_configuration64 *>(symBuf));
+    prepareLoadConfig(
+        ctx.primaryTarget,
+        reinterpret_cast<coff_load_configuration64 *>(loadConfigBuf));
   else
-    prepareLoadConfig(reinterpret_cast<coff_load_configuration32 *>(symBuf));
+    prepareLoadConfig(
+        ctx.primaryTarget,
+        reinterpret_cast<coff_load_configuration32 *>(loadConfigBuf));
+
+  if (ctx.hybridTarget) {
+    void *hybridLoadConfigBuf = getLoadConfigBuffer(*ctx.hybridTarget);
+    if (!hybridLoadConfigBuf) {
+      warn("EC '_load_config_used' is missing");
+      return;
+    }
+
+    auto loadConfig =
+        reinterpret_cast<coff_load_configuration64 *>(loadConfigBuf);
+    auto hybridLoadConfig =
+        reinterpret_cast<coff_load_configuration64 *>(hybridLoadConfigBuf);
+    prepareLoadConfig(ctx.primaryTarget, hybridLoadConfig);
+    loadConfig->CHPEMetadataPointer = hybridLoadConfig->CHPEMetadataPointer;
+  }
 }
 
-template <typename T> void Writer::prepareLoadConfig(T *loadConfig) {
+template <typename T>
+void Writer::prepareLoadConfig(COFFTargetContext &target, T *loadConfig) {
   if (ctx.config.dependentLoadFlags)
     loadConfig->DependentLoadFlags = ctx.config.dependentLoadFlags;
+  if (dynamicRelocsChunk) {
+    loadConfig->DynamicValueRelocTableSection = relocSec->sectionIndex;
+    loadConfig->DynamicValueRelocTableOffset =
+        dynamicRelocsChunk->getRVA() - relocSec->getRVA();
+  }
 
-  checkLoadConfigGuardData(loadConfig);
+  checkLoadConfigGuardData(target, loadConfig);
 }
 
 template <typename T>
-void Writer::checkLoadConfigGuardData(const T *loadConfig) {
+void Writer::checkLoadConfigGuardData(COFFTargetContext &target,
+                                      const T *loadConfig) {
   size_t loadConfigSize = loadConfig->Size;
 
 #define RETURN_IF_NOT_CONTAINS(field)                                          \
@@ -2585,12 +2828,12 @@ void Writer::checkLoadConfigGuardData(const T *loadConfig) {
   if (loadConfigSize >= offsetof(T, field) + sizeof(T::field))
 
 #define CHECK_VA(field, sym)                                                   \
-  if (auto *s = dyn_cast<DefinedSynthetic>(ctx.symtab.findUnderscore(sym)))    \
+  if (auto *s = dyn_cast<DefinedSynthetic>(target.symtab.findUnderscore(sym))) \
     if (loadConfig->field != ctx.config.imageBase + s->getRVA())               \
       warn(#field " not set correctly in '_load_config_used'");
 
 #define CHECK_ABSOLUTE(field, sym)                                             \
-  if (auto *s = dyn_cast<DefinedAbsolute>(ctx.symtab.findUnderscore(sym)))     \
+  if (auto *s = dyn_cast<DefinedAbsolute>(target.symtab.findUnderscore(sym)))  \
     if (loadConfig->field != s->getVA())                                       \
       warn(#field " not set correctly in '_load_config_used'");
 
diff --git a/lld/test/COFF/Inputs/loadconfig-arm64.s b/lld/test/COFF/Inputs/loadconfig-arm64.s
new file mode 100644
index 000000000000..eb47d4d281e5
--- /dev/null
+++ b/lld/test/COFF/Inputs/loadconfig-arm64.s
@@ -0,0 +1,46 @@
+        .section .rdata,"dr"
+        .globl _load_config_used
+        .p2align 3, 0
+_load_config_used:
+        .word 0x140
+        .fill 0x54, 1, 0
+        .xword 0 // __security_cookie
+        .fill 0x10, 1, 0
+        .xword 0 // __guard_check_icall_fptr
+        .xword 0 // __guard_dispatch_icall_fptr
+        .xword __guard_fids_table
+        .xword __guard_fids_count
+        .xword __guard_flags
+        .xword 0
+        .xword __guard_iat_table
+        .xword __guard_iat_count
+        .xword __guard_longjmp_table
+        .xword __guard_longjmp_count
+        .xword 0
+        .xword 0
+        .fill 0x60, 1, 0
+        .xword 0 // __castguard_check_failure_os_handled_fptr
+        .xword 0
+
+        /*
+        .text
+_guard_dispatch_icall_nop:
+        br x9
+        */
+
+        /*
+        .section ".00cfg","dr"
+__guard_dispatch_icall_fptr:
+        .xword 0 //_guard_dispatch_icall_nop
+        */
+
+        /*
+__guard_check_icall_fptr:
+        .xword 0
+__guard_dispatch_icall_fptr:
+        .xword 0
+__castguard_check_failure_os_handled_fptr:
+        .xword 0
+__security_cookie:
+        .xword 0
+*/
diff --git a/lld/test/COFF/arm64ec-codemap.test b/lld/test/COFF/arm64ec-codemap.test
index 7f4d5d84b458..f67739f0f05e 100644
--- a/lld/test/COFF/arm64ec-codemap.test
+++ b/lld/test/COFF/arm64ec-codemap.test
@@ -9,6 +9,7 @@ RUN: llvm-mc -filetype=obj -triple=arm64ec-windows data-sec2.s -o data-sec2.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows empty-sec.s -o arm64ec-empty-sec.obj
 RUN: llvm-mc -filetype=obj -triple=x86_64-windows x86_64-func-sym.s -o x86_64-func-sym.obj
 RUN: llvm-mc -filetype=obj -triple=x86_64-windows empty-sec.s -o x86_64-empty-sec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
 
 Link ARM64EC DLL and verify that the code is arranged as expected.
@@ -51,7 +52,7 @@ RUN: llvm-readobj --coff-load-config test2.dll | FileCheck -check-prefix=CODEMAP
 RUN: llvm-objdump -d test2.dll | FileCheck -check-prefix=DISASM %s
 
 RUN: lld-link -out:testx.dll -machine:arm64x arm64-func-sym.obj arm64ec-func-sym.obj \
-RUN:          x86_64-func-sym.obj loadconfig-arm64ec.obj -dll -noentry
+RUN:          x86_64-func-sym.obj loadconfig-arm64.obj loadconfig-arm64ec.obj -dll -noentry
 
 Adding empty chunks does not affect code map ranges.
 
diff --git a/lld/test/COFF/arm64ec-export-thunks.test b/lld/test/COFF/arm64ec-export-thunks.test
index 7a4215318f0e..71111ebe7366 100644
--- a/lld/test/COFF/arm64ec-export-thunks.test
+++ b/lld/test/COFF/arm64ec-export-thunks.test
@@ -48,7 +48,7 @@ EXP-DISASM-NEXT: 18000301f: cc                           int3
 RUN: llvm-objdump -p exports.dll | FileCheck -check-prefix=EXP-EXPORT %s
 EXP-EXPORT:      Ordinal      RVA  Name
 EXP-EXPORT-NEXT:       1   0x3000  arm64ec_func
-EXP-EXPORT-NEXT:       2   0x6000  data_sym
+EXP-EXPORT-NEXT:       2   0x7000  data_sym
 EXP-EXPORT-NEXT:       3   0x3010  func
 EXP-EXPORT-NEXT:       4   0x2000  x86_64_func
 
@@ -67,7 +67,7 @@ EXP-CHPE-NEXT:    0x3010 -> 0x1000
 EXP-CHPE-NEXT:  ]
 
 RUN: llvm-objdump -s --section=.test exports.dll | FileCheck --check-prefix=EXP-DATA %s
-EXP-DATA: 180006000 10300000 00300000
+EXP-DATA: 180007000 10300000 00300000
 
 RUN: lld-link -out:exports.dll -machine:arm64ec antidep-func.obj x86_64-func.obj loadconfig-arm64ec.obj \
 RUN:          arm64ec-data.obj -dll -noentry -export:arm64ec_func -export:func=arm64ec_func \
diff --git a/lld/test/COFF/arm64ec-patchable-thunks.test b/lld/test/COFF/arm64ec-patchable-thunks.test
index 5459b5483eab..dd21d2812816 100644
--- a/lld/test/COFF/arm64ec-patchable-thunks.test
+++ b/lld/test/COFF/arm64ec-patchable-thunks.test
@@ -4,6 +4,7 @@ RUN: split-file %s %t.dir && cd %t.dir
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-patchable.s -o arm64ec-patchable.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-alias.s -o arm64ec-alias.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
 
 RUN: lld-link -out:test.dll -machine:arm64ec arm64ec-patchable.obj loadconfig-arm64ec.obj -dll -noentry
 
@@ -26,7 +27,7 @@ PATCH-DISASM-NEXT: 18000200e: cc                           int3
 PATCH-DISASM-NEXT: 18000200f: cc                           int3
 
 RUN: llvm-readobj --hex-dump=.test test.dll | FileCheck -check-prefix=RVA %s
-RVA: 0x180005000 00200000
+RVA: 0x180006000 00200000
 
 RUN: llvm-readobj --coff-load-config test.dll | FileCheck -check-prefix=PATCH-CHPE %s
 PATCH-CHPE:       CodeMap [
@@ -42,11 +43,35 @@ PATCH-CHPE-NEXT:  ]
 
 
 RUN: lld-link -out:test2.dll -machine:arm64ec arm64ec-alias.obj loadconfig-arm64ec.obj -dll -noentry
-
 RUN: llvm-objdump -d test2.dll | FileCheck -check-prefix=PATCH-DISASM %s
 RUN: llvm-readobj --hex-dump=.test test2.dll | FileCheck -check-prefix=RVA %s
 RUN: llvm-readobj --coff-load-config test2.dll | FileCheck -check-prefix=PATCH-CHPE %s
 
+RUN: lld-link -out:testx.dll -machine:arm64x arm64ec-patchable.obj loadconfig-arm64.obj \
+RUN:          loadconfig-arm64ec.obj -dll -noentry
+
+RUN: llvm-objdump -d testx.dll | FileCheck -check-prefix=PATCH-DISASMX %s
+PATCH-DISASMX:      0000000180001000 <.text>:
+PATCH-DISASMX-NEXT: 180001000: 52800040     mov     w0, #0x2                // =2
+PATCH-DISASMX-NEXT: 180001004: d65f03c0     ret
+PATCH-DISASMX-EMPTY:
+PATCH-DISASMX-NEXT: Disassembly of section .hexpthk:
+PATCH-DISASMX-EMPTY:
+PATCH-DISASMX-NEXT: 0000000180002000 <.hexpthk>:
+PATCH-DISASMX-NEXT: 180002000: 48 8b c4                     movq    %rsp, %rax
+PATCH-DISASMX-NEXT: 180002003: 48 89 58 20                  movq    %rbx, 0x20(%rax)
+PATCH-DISASMX-NEXT: 180002007: 55                           pushq   %rbp
+PATCH-DISASMX-NEXT: 180002008: 5d                           popq    %rbp
+PATCH-DISASMX-NEXT: 180002009: e9 f2 ef ff ff               jmp     0x180001000 <.text>
+PATCH-DISASMX-NEXT: 18000200e: cc                           int3
+PATCH-DISASMX-NEXT: 18000200f: cc                           int3
+
+RUN: llvm-readobj --coff-load-config testx.dll | FileCheck -check-prefix=PATCH-CHPE %s
+
+RUN: lld-link -out:testx2.dll -machine:arm64x arm64ec-alias.obj loadconfig-arm64.obj \
+RUN:          loadconfig-arm64ec.obj -dll -noentry
+RUN: llvm-readobj --coff-load-config testx2.dll | FileCheck -check-prefix=PATCH-CHPE %s
+
 #--- arm64ec-patchable.s
     .section ".text", "x", discard, "#patchable_func$hp_target"
     .globl "#patchable_func$hp_target"
diff --git a/lld/test/COFF/arm64x-delay-import.test b/lld/test/COFF/arm64x-delay-import.test
new file mode 100644
index 000000000000..26c6125cecf0
--- /dev/null
+++ b/lld/test/COFF/arm64x-delay-import.test
@@ -0,0 +1,222 @@
+REQUIRES: aarch64, x86
+RUN: split-file %s %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test-arm64ec.s -o test-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test-arm64.s -o test-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-stubs.s -o arm64ec-stubs.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-stubs.s -o arm64-stubs.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
+RUN: llvm-lib -machine:arm64ec -def:test.def -out:test-arm64ec.lib
+RUN: llvm-lib -machine:arm64 -def:test.def -out:test-arm64.lib
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:out.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          arm64-stubs.obj arm64ec-stubs.obj test-arm64.obj test-arm64ec.obj test-arm64.lib test-arm64ec.lib -delayload:test.dll
+
+RUN: llvm-readobj --hex-dump=.test out.dll | FileCheck -check-prefix=TESTSEC %s
+TESTSEC: 0x180007000 a8500000 98500000 00300000 10200000
+
+RUN: llvm-readobj --hex-dump=.testa out.dll | FileCheck -check-prefix=TESTSECA %s
+TESTSECA: 0x180008000 88500000 08100000
+
+RUN: llvm-objdump -d out.dll | FileCheck -check-prefix=DISASM %s
+DISASM:      0000000180001000 <.text>:
+DISASM-NEXT: 180001000: 52800060     mov     w0, #0x3                // =3
+DISASM-NEXT: 180001004: d65f03c0     ret
+DISASM-NEXT: 180001008: 90000030     adrp    x16, 0x180005000
+DISASM-NEXT: 18000100c: f9404610     ldr     x16, [x16, #0x88]
+DISASM-NEXT: 180001010: d61f0200     br      x16
+DISASM-NEXT: 180001014: 90000031     adrp    x17, 0x180005000
+DISASM-NEXT: 180001018: 91022231     add     x17, x17, #0x88
+DISASM-NEXT: 18000101c: 14000001     b       0x180001020 <.text+0x20>
+DISASM-NEXT: 180001020: a9b37bfd     stp     x29, x30, [sp, #-0xd0]!
+DISASM-NEXT: 180001024: 910003fd     mov     x29, sp
+DISASM-NEXT: 180001028: a90107e0     stp     x0, x1, [sp, #0x10]
+DISASM-NEXT: 18000102c: a9020fe2     stp     x2, x3, [sp, #0x20]
+DISASM-NEXT: 180001030: a90317e4     stp     x4, x5, [sp, #0x30]
+DISASM-NEXT: 180001034: a9041fe6     stp     x6, x7, [sp, #0x40]
+DISASM-NEXT: 180001038: ad0287e0     stp     q0, q1, [sp, #0x50]
+DISASM-NEXT: 18000103c: ad038fe2     stp     q2, q3, [sp, #0x70]
+DISASM-NEXT: 180001040: ad0497e4     stp     q4, q5, [sp, #0x90]
+DISASM-NEXT: 180001044: ad059fe6     stp     q6, q7, [sp, #0xb0]
+DISASM-NEXT: 180001048: aa1103e1     mov     x1, x17
+DISASM-NEXT: 18000104c: f0000000     adrp    x0, 0x180004000
+DISASM-NEXT: 180001050: 910ce000     add     x0, x0, #0x338
+DISASM-NEXT: 180001054: 97ffffeb     bl      0x180001000 <.text>
+DISASM-NEXT: 180001058: aa0003f0     mov     x16, x0
+DISASM-NEXT: 18000105c: ad459fe6     ldp     q6, q7, [sp, #0xb0]
+DISASM-NEXT: 180001060: ad4497e4     ldp     q4, q5, [sp, #0x90]
+DISASM-NEXT: 180001064: ad438fe2     ldp     q2, q3, [sp, #0x70]
+DISASM-NEXT: 180001068: ad4287e0     ldp     q0, q1, [sp, #0x50]
+DISASM-NEXT: 18000106c: a9441fe6     ldp     x6, x7, [sp, #0x40]
+DISASM-NEXT: 180001070: a94317e4     ldp     x4, x5, [sp, #0x30]
+DISASM-NEXT: 180001074: a9420fe2     ldp     x2, x3, [sp, #0x20]
+DISASM-NEXT: 180001078: a94107e0     ldp     x0, x1, [sp, #0x10]
+DISASM-NEXT: 18000107c: a8cd7bfd     ldp     x29, x30, [sp], #0xd0
+DISASM-NEXT: 180001080: d61f0200     br      x16
+DISASM-NEXT:                 ...
+DISASM-NEXT: 180002000: 52800040     mov     w0, #0x2                // =2
+DISASM-NEXT: 180002004: d65f03c0     ret
+DISASM-NEXT: 180002008: 52800060     mov     w0, #0x3                // =3
+DISASM-NEXT: 18000200c: d65f03c0     ret
+DISASM-NEXT: 180002010: f0000010     adrp    x16, 0x180005000
+DISASM-NEXT: 180002014: f9405610     ldr     x16, [x16, #0xa8]
+DISASM-NEXT: 180002018: d61f0200     br      x16
+DISASM-NEXT: 18000201c: f000000b     adrp    x11, 0x180005000
+DISASM-NEXT: 180002020: f9404d6b     ldr     x11, [x11, #0x98]
+DISASM-NEXT: 180002024: 9000000a     adrp    x10, 0x180002000 <.text+0x1000>
+DISASM-NEXT: 180002028: 9102e14a     add     x10, x10, #0xb8
+DISASM-NEXT: 18000202c: 17fffff5     b       0x180002000 <.text+0x1000>
+DISASM-NEXT: 180002030: f0000011     adrp    x17, 0x180005000
+DISASM-NEXT: 180002034: 91026231     add     x17, x17, #0x98
+DISASM-NEXT: 180002038: f81f0ffe     str     x30, [sp, #-0x10]!
+DISASM-NEXT: 18000203c: 94000007     bl      0x180002058 <.text+0x1058>
+DISASM-NEXT: 180002040: f84107fe     ldr     x30, [sp], #0x10
+DISASM-NEXT: 180002044: 90000008     adrp    x8, 0x180002000 <.text+0x1000>
+DISASM-NEXT: 180002048: 91007108     add     x8, x8, #0x1c
+DISASM-NEXT: 18000204c: f0000009     adrp    x9, 0x180005000
+DISASM-NEXT: 180002050: f9005528     str     x8, [x9, #0xa8]
+DISASM-NEXT: 180002054: d61f0100     br      x8
+DISASM-NEXT: 180002058: a9b37bfd     stp     x29, x30, [sp, #-0xd0]!
+DISASM-NEXT: 18000205c: 910003fd     mov     x29, sp
+DISASM-NEXT: 180002060: a90107e0     stp     x0, x1, [sp, #0x10]
+DISASM-NEXT: 180002064: a9020fe2     stp     x2, x3, [sp, #0x20]
+DISASM-NEXT: 180002068: a90317e4     stp     x4, x5, [sp, #0x30]
+DISASM-NEXT: 18000206c: a9041fe6     stp     x6, x7, [sp, #0x40]
+DISASM-NEXT: 180002070: ad0287e0     stp     q0, q1, [sp, #0x50]
+DISASM-NEXT: 180002074: ad038fe2     stp     q2, q3, [sp, #0x70]
+DISASM-NEXT: 180002078: ad0497e4     stp     q4, q5, [sp, #0x90]
+DISASM-NEXT: 18000207c: ad059fe6     stp     q6, q7, [sp, #0xb0]
+DISASM-NEXT: 180002080: aa1103e1     mov     x1, x17
+DISASM-NEXT: 180002084: d0000000     adrp    x0, 0x180004000
+DISASM-NEXT: 180002088: 910ce000     add     x0, x0, #0x338
+DISASM-NEXT: 18000208c: 97ffffdf     bl      0x180002008 <.text+0x1008>
+DISASM-NEXT: 180002090: ad459fe6     ldp     q6, q7, [sp, #0xb0]
+DISASM-NEXT: 180002094: ad4497e4     ldp     q4, q5, [sp, #0x90]
+DISASM-NEXT: 180002098: ad438fe2     ldp     q2, q3, [sp, #0x70]
+DISASM-NEXT: 18000209c: ad4287e0     ldp     q0, q1, [sp, #0x50]
+DISASM-NEXT: 1800020a0: a9441fe6     ldp     x6, x7, [sp, #0x40]
+DISASM-NEXT: 1800020a4: a94317e4     ldp     x4, x5, [sp, #0x30]
+DISASM-NEXT: 1800020a8: a9420fe2     ldp     x2, x3, [sp, #0x20]
+DISASM-NEXT: 1800020ac: a94107e0     ldp     x0, x1, [sp, #0x10]
+DISASM-NEXT: 1800020b0: a8cd7bfd     ldp     x29, x30, [sp], #0xd0
+DISASM-NEXT: 1800020b4: d65f03c0     ret
+DISASM-NEXT: 1800020b8: 52800080     mov     w0, #0x4                // =4
+DISASM-NEXT: 1800020bc: d65f03c0     ret
+DISASM-NEXT:                 ...
+DISASM-NEXT: 180003000: ff 25 92 20 00 00            jmpq    *0x2092(%rip)           # 0x180005098
+DISASM-NEXT: 180003006: 48 8d 05 8b 20 00 00         leaq    0x208b(%rip), %rax      # 0x180005098
+DISASM-NEXT: 18000300d: e9 00 00 00 00               jmp     0x180003012 <.text+0x2012>
+DISASM-NEXT: 180003012: 51                           pushq   %rcx
+DISASM-NEXT: 180003013: 52                           pushq   %rdx
+DISASM-NEXT: 180003014: 41 50                        pushq   %r8
+DISASM-NEXT: 180003016: 41 51                        pushq   %r9
+DISASM-NEXT: 180003018: 48 83 ec 48                  subq    $0x48, %rsp
+DISASM-NEXT: 18000301c: 66 0f 7f 04 24               movdqa  %xmm0, (%rsp)
+DISASM-NEXT: 180003021: 66 0f 7f 4c 24 10            movdqa  %xmm1, 0x10(%rsp)
+DISASM-NEXT: 180003027: 66 0f 7f 54 24 20            movdqa  %xmm2, 0x20(%rsp)
+DISASM-NEXT: 18000302d: 66 0f 7f 5c 24 30            movdqa  %xmm3, 0x30(%rsp)
+DISASM-NEXT: 180003033: 48 8b d0                     movq    %rax, %rdx
+DISASM-NEXT: 180003036: 48 8d 0d fb 12 00 00         leaq    0x12fb(%rip), %rcx      # 0x180004338
+DISASM-NEXT: 18000303d: e8 c6 ef ff ff               callq   0x180002008 <.text+0x1008>
+DISASM-NEXT: 180003042: 66 0f 6f 04 24               movdqa  (%rsp), %xmm0
+DISASM-NEXT: 180003047: 66 0f 6f 4c 24 10            movdqa  0x10(%rsp), %xmm1
+DISASM-NEXT: 18000304d: 66 0f 6f 54 24 20            movdqa  0x20(%rsp), %xmm2
+DISASM-NEXT: 180003053: 66 0f 6f 5c 24 30            movdqa  0x30(%rsp), %xmm3
+DISASM-NEXT: 180003059: 48 83 c4 48                  addq    $0x48, %rsp
+DISASM-NEXT: 18000305d: 41 59                        popq    %r9
+DISASM-NEXT: 18000305f: 41 58                        popq    %r8
+DISASM-NEXT: 180003061: 5a                           popq    %rdx
+DISASM-NEXT: 180003062: 59                           popq    %rcx
+DISASM-NEXT: 180003063: ff e0                        jmpq    *%rax
+
+RUN: llvm-readobj --coff-imports out.dll | FileCheck -check-prefix=IMPORTS %s
+IMPORTS:      DelayImport {
+IMPORTS-NEXT:   Name: test.dll
+IMPORTS-NEXT:   Attributes: 0x1
+IMPORTS-NEXT:   ModuleHandle: 0x5080
+IMPORTS-NEXT:   ImportAddressTable: 0x5088
+IMPORTS-NEXT:   ImportNameTable: 0x4378
+IMPORTS-NEXT:   BoundDelayImportTable: 0x0
+IMPORTS-NEXT:   UnloadDelayImportTable: 0x0
+IMPORTS-NEXT:   Import {
+IMPORTS-NEXT:     Symbol: myfunc (0)
+IMPORTS-NEXT:     Address: 0x180001014
+IMPORTS-NEXT:   }
+IMPORTS-NEXT: }
+IMPORTS-NEXT: HybridObject {
+IMPORTS:        DelayImport {
+IMPORTS-NEXT:     Name: test.dll
+IMPORTS-NEXT:     Attributes: 0x1
+IMPORTS-NEXT:     ModuleHandle: 0x5080
+IMPORTS-NEXT:     ImportAddressTable: 0x5098
+IMPORTS-NEXT:     ImportNameTable: 0x4388
+IMPORTS-NEXT:     BoundDelayImportTable: 0x0
+IMPORTS-NEXT:     UnloadDelayImportTable: 0x0
+IMPORTS-NEXT:     Import {
+IMPORTS-NEXT:       Symbol: myfunc (0)
+IMPORTS-NEXT:       Address: 0x180003006
+IMPORTS-NEXT:     }
+IMPORTS-NEXT:   }
+IMPORTS-NEXT: }
+
+
+#--- test-arm64ec.s
+    .section .test, "rd"
+    .rva __imp_myfunc
+    .rva __imp_aux_myfunc
+    .rva myfunc
+    .rva "#myfunc"
+
+#--- test-arm64.s
+    .section .testa, "rd"
+    .rva __imp_myfunc
+    .rva myfunc
+
+#--- arm64ec-stubs.s
+    .text
+    .globl __icall_helper_arm64ec
+    .p2align 2, 0x0
+__icall_helper_arm64ec:
+    mov w0, #2
+    ret
+
+    .text
+    .globl "#__delayLoadHelper2"
+    .p2align 2, 0x0
+"#__delayLoadHelper2":
+    mov w0, #3
+    ret
+
+    .section .cfg, "r"
+    .globl __os_arm64x_dispatch_icall
+    .p2align 2, 0x0
+__os_arm64x_dispatch_icall:
+    .xword 1
+
+    .section .hybmp$x, "yi"
+    .symidx __imp_myfunc
+    .symidx myfunc_exit_thunk
+    .word 4
+
+    .section .wowthk$aa,"xr",discard,myfunc_exit_thunk
+    .globl myfunc_exit_thunk
+myfunc_exit_thunk:
+    mov w0, #4
+    ret
+
+#--- arm64-stubs.s
+    .text
+    .text
+    .globl __delayLoadHelper2
+    .p2align 2, 0x0
+__delayLoadHelper2:
+    mov w0, #3
+    ret
+
+#--- test.def
+NAME test.dll
+EXPORTS
+    mydata DATA
+    myfunc
+    otherfunc
diff --git a/lld/test/COFF/arm64x-entry.test b/lld/test/COFF/arm64x-entry.test
new file mode 100644
index 000000000000..63537af3f1bb
--- /dev/null
+++ b/lld/test/COFF/arm64x-entry.test
@@ -0,0 +1,101 @@
+REQUIRES: aarch64
+RUN: split-file %s %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-dllmain.s -o arm64ec-dllmain.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-dllmain.s -o arm64-dllmain.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-func.s -o arm64ec-func.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-func.s -o arm64-func.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64-drectve.s -o arm64ec-drectve.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-drectve.s -o arm64-drectve.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
+
+RUN: lld-link -machine:arm64x -dll -out:out.dll arm64ec-dllmain.obj arm64-dllmain.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj
+
+RUN: llvm-objdump -d out.dll | FileCheck -check-prefix=DISASM %s
+DISASM: Disassembly of section .text:
+DISASM-EMPTY:
+DISASM-NEXT: 0000000180001000 <.text>:
+DISASM-NEXT: 180001000: 52800020     mov     w0, #0x1                // =1
+DISASM-NEXT: 180001004: d65f03c0     ret
+DISASM-NEXT:                 ...
+DISASM-NEXT: 180002000: 52800040     mov     w0, #0x2                // =2
+DISASM-NEXT: 180002004: d65f03c0     ret
+DISASM-EMPTY:
+DISASM-NEXT: Disassembly of section .hexpthk:
+DISASM-EMPTY:
+DISASM-NEXT: 0000000180003000 <.hexpthk>:
+DISASM-NEXT: 180003000: 48 8b c4                     movq    %rsp, %rax
+DISASM-NEXT: 180003003: 48 89 58 20                  movq    %rbx, 0x20(%rax)
+DISASM-NEXT: 180003007: 55                           pushq   %rbp
+DISASM-NEXT: 180003008: 5d                           popq    %rbp
+DISASM-NEXT: 180003009: e9 f2 ef ff ff               jmp     0x180002000 <.text+0x1000>
+DISASM-NEXT: 18000300e: cc                           int3
+DISASM-NEXT: 18000300f: cc                           int3
+
+RUN: llvm-readobj --headers out.dll | FileCheck -check-prefix=HEADERS %s
+HEADERS: AddressOfEntryPoint: 0x1000
+HEADERS: HybridObject {
+HEADERS:   AddressOfEntryPoint: 0x3000
+HEADERS: }
+
+RUN: llvm-readobj --coff-load-config out.dll | FileCheck -check-prefix=LOADCFG %s
+LOADCFG: AlternateEntryPoint: 0x2000
+LOADCFG: HybridObject {
+LOADCFG:   AlternateEntryPoint: 0x1000
+LOADCFG: }
+
+RUN: lld-link -machine:arm64x -dll -out:out2.dll arm64ec-func.obj arm64-func.obj \
+RUN:          arm64ec-drectve.obj loadconfig-arm64.obj loadconfig-arm64ec.obj
+RUN: llvm-objdump -d out2.dll | FileCheck -check-prefix=DISASM %s
+RUN: llvm-readobj --headers out2.dll | FileCheck -check-prefix=HEADERS %s
+RUN: llvm-readobj --coff-load-config out2.dll | FileCheck -check-prefix=LOADCFG %s
+
+RUN: lld-link -machine:arm64x -dll -out:out3.dll arm64ec-func.obj arm64-func.obj \
+RUN:          arm64-drectve.obj loadconfig-arm64.obj loadconfig-arm64ec.obj
+RUN: llvm-objdump -d out3.dll | FileCheck -check-prefix=DISASM %s
+RUN: llvm-readobj --headers out3.dll | FileCheck -check-prefix=HEADERS %s
+RUN: llvm-readobj --coff-load-config out3.dll | FileCheck -check-prefix=LOADCFG %s
+
+RUN: lld-link -machine:arm64x -dll -out:out4.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj -entry:func
+RUN: llvm-objdump -d out4.dll | FileCheck -check-prefix=DISASM %s
+RUN: llvm-readobj --headers out4.dll | FileCheck -check-prefix=HEADERS %s
+RUN: llvm-readobj --coff-load-config out4.dll | FileCheck -check-prefix=LOADCFG %s
+
+#--- arm64-dllmain.s
+    .section .text,"xr",discard,_DllMainCRTStartup
+    .globl _DllMainCRTStartup
+    .p2align 2
+_DllMainCRTStartup:
+    mov w0, #1
+    ret
+
+#--- arm64ec-dllmain.s
+    .section .text,"xr",discard,_DllMainCRTStartup
+    .globl _DllMainCRTStartup
+    .p2align 2
+_DllMainCRTStartup:
+    mov w0, #2
+    ret
+
+#--- arm64-func.s
+    .section .text,"xr",discard,func
+    .globl func
+    .p2align 2
+func:
+    mov w0, #1
+    ret
+
+#--- arm64ec-func.s
+    .section .text,"xr",discard,func
+    .globl func
+    .p2align 2
+func:
+    mov w0, #2
+    ret
+
+#--- arm64-drectve.s
+.section .drectve
+    .ascii "-entry:func"
diff --git a/lld/test/COFF/arm64x-export.test b/lld/test/COFF/arm64x-export.test
new file mode 100644
index 000000000000..d4cd600a9818
--- /dev/null
+++ b/lld/test/COFF/arm64x-export.test
@@ -0,0 +1,120 @@
+REQUIRES: aarch64
+RUN: split-file %s %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-func.s -o arm64ec-func.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-func.s -o arm64-func.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64-drectve.s -o arm64ec-drectve.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows arm64-drectve.s -o arm64-drectve.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
+
+Exporting with a command line argument exports only EC function.
+
+RUN: lld-link -machine:arm64x -dll -out:out.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj -noentry -export:func
+
+RUN: llvm-objdump -d out.dll | FileCheck -check-prefix=DISASMEC %s
+DISASMEC:      Disassembly of section .text:
+DISASMEC-EMPTY:
+DISASMEC-NEXT: 0000000180001000 <.text>:
+DISASMEC-NEXT: 180001000: 52800040     mov     w0, #0x2                // =2
+DISASMEC-NEXT: 180001004: d65f03c0     ret
+DISASMEC-EMPTY:
+DISASMEC-NEXT: Disassembly of section .hexpthk:
+DISASMEC-EMPTY:
+DISASMEC-NEXT: 0000000180002000 <.hexpthk>:
+DISASMEC-NEXT: 180002000: 48 8b c4                     movq    %rsp, %rax
+DISASMEC-NEXT: 180002003: 48 89 58 20                  movq    %rbx, 0x20(%rax)
+DISASMEC-NEXT: 180002007: 55                           pushq   %rbp
+DISASMEC-NEXT: 180002008: 5d                           popq    %rbp
+DISASMEC-NEXT: 180002009: e9 f2 ef ff ff               jmp     0x180001000 <.text>
+DISASMEC-NEXT: 18000200e: cc                           int3
+DISASMEC-NEXT: 18000200f: cc                           int3
+
+RUN: llvm-readobj --coff-exports out.dll | FileCheck -check-prefix=EXPORTSEC %s
+EXPORTSEC-NOT:  Name: func
+EXPORTSEC:      HybridObject {
+EXPORTSEC:        Export {
+EXPORTSEC-NEXT:     Ordinal: 1
+EXPORTSEC-NEXT:     Name: func
+EXPORTSEC-NEXT:     RVA: 0x2000
+EXPORTSEC-NEXT:   }
+EXPORTSEC-NEXT: }
+
+
+RUN: lld-link -machine:arm64x -dll -out:out2.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj arm64ec-drectve.obj -noentry
+RUN: llvm-objdump -d out2.dll | FileCheck -check-prefix=DISASMEC %s
+RUN: llvm-readobj --coff-exports out2.dll | FileCheck -check-prefix=EXPORTSEC %s
+
+
+RUN: lld-link -machine:arm64x -dll -out:out3.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj arm64-drectve.obj -noentry
+
+RUN: llvm-objdump -d out3.dll | FileCheck -check-prefix=DISASMNATIVE %s
+DISASMNATIVE:      Disassembly of section .text:
+DISASMNATIVE-EMPTY:
+DISASMNATIVE-NEXT: 0000000180001000 <func>:
+DISASMNATIVE-NEXT: 180001000: 52800020     mov     w0, #0x1                // =1
+DISASMNATIVE-NEXT: 180001004: d65f03c0     ret
+
+RUN: llvm-readobj --coff-exports out3.dll | FileCheck -check-prefix=EXPORTSNATIVE %s
+EXPORTSNATIVE:      Export {
+EXPORTSNATIVE-NEXT:   Ordinal: 1
+EXPORTSNATIVE-NEXT:   Name: func
+EXPORTSNATIVE-NEXT:   RVA: 0x1000
+EXPORTSNATIVE-NEXT: }
+EXPORTSNATIVE:      HybridObject {
+EXPORTSNATIVE-NOT:  Name: func
+
+
+RUN: lld-link -machine:arm64x -dll -out:out2.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj arm64ec-drectve.obj -noentry
+RUN: llvm-objdump -d out2.dll | FileCheck -check-prefix=DISASMEC %s
+RUN: llvm-readobj --coff-exports out2.dll | FileCheck -check-prefix=EXPORTSEC %s
+
+
+RUN: lld-link -machine:arm64x -dll -out:out4.dll arm64ec-func.obj arm64-func.obj \
+RUN:          loadconfig-arm64.obj loadconfig-arm64ec.obj arm64-drectve.obj arm64ec-drectve.obj -noentry
+
+RUN: llvm-objdump -d out4.dll | FileCheck -check-prefix=DISASMX %s
+DISASMX:      Disassembly of section .text:
+DISASMX-EMPTY:
+DISASMX-NEXT: 0000000180001000 <func>:
+DISASMX-NEXT: 180001000: 52800020     mov     w0, #0x1                // =1
+DISASMX-NEXT: 180001004: d65f03c0     ret
+
+RUN: llvm-readobj --coff-exports out4.dll | FileCheck -check-prefix=EXPORTSX %s
+EXPORTSX:      Export {
+EXPORTSX-NEXT:   Ordinal: 1
+EXPORTSX-NEXT:   Name: func
+EXPORTSX-NEXT:   RVA: 0x1000
+EXPORTSX-NEXT: }
+EXPORTSX:      HybridObject {
+EXPORTSX:        Export {
+EXPORTSX-NEXT:     Ordinal: 1
+EXPORTSX-NEXT:     Name: func
+EXPORTSX-NEXT:     RVA: 0x3000
+EXPORTSX-NEXT:   }
+EXPORTSX-NEXT: }
+
+
+#--- arm64-func.s
+    .section .text,"xr",discard,func
+    .globl func
+    .p2align 2
+func:
+    mov w0, #1
+    ret
+
+#--- arm64ec-func.s
+    .section .text,"xr",discard,func
+    .globl func
+    .p2align 2
+func:
+    mov w0, #2
+    ret
+
+#--- arm64-drectve.s
+.section .drectve
+    .ascii "-export:func"
diff --git a/lld/test/COFF/arm64x-import.test b/lld/test/COFF/arm64x-import.test
new file mode 100644
index 000000000000..28c6bb4e1851
--- /dev/null
+++ b/lld/test/COFF/arm64x-import.test
@@ -0,0 +1,326 @@
+REQUIRES: aarch64
+RUN: split-file %s %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test1-arm64ec.s -o test1-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test1-arm64.s -o test1-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test2-arm64ec.s -o test2-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test2-arm64.s -o test2-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test3-arm64ec.s -o test3-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test3-arm64.s -o test3-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test4-arm64ec.s -o test4-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test4-arm64.s -o test4-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows test5-arm64ec.s -o test5-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows test5-arm64.s -o test5-arm64.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows stubs.s -o stubs.obj
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
+RUN: llvm-lib -machine:arm64ec -def:test.def -out:test-arm64ec.lib
+RUN: llvm-lib -machine:arm64 -def:test.def -out:test-arm64.lib
+RUN: llvm-lib -machine:arm64ec -def:test2.def -out:test2-arm64ec.lib
+RUN: llvm-lib -machine:arm64 -def:test2.def -out:test2-arm64.lib
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:test1.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          stubs.obj test1-arm64ec.obj test1-arm64.obj test-arm64ec.lib test-arm64.lib
+
+RUN: llvm-objdump -d test1.dll | FileCheck -check-prefix=DISASM1 %s
+DISASM1:      0000000180001000 <.text>:
+DISASM1-NEXT: 180001000: f0000010     adrp    x16, 0x180004000
+DISASM1-NEXT: 180001004: f9400610     ldr     x16, [x16, #0x8]
+DISASM1-NEXT: 180001008: d61f0200     br      x16
+DISASM1-NEXT:                 ...
+DISASM1-NEXT: 180002000: 52800040     mov     w0, #0x2                // =2
+DISASM1-NEXT: 180002004: d65f03c0     ret
+DISASM1-NEXT: 180002008: 90000030     adrp    x16, 0x180006000
+DISASM1-NEXT: 18000200c: f9400210     ldr     x16, [x16]
+DISASM1-NEXT: 180002010: d61f0200     br      x16
+DISASM1-NEXT: 180002014: d000000b     adrp    x11, 0x180004000
+DISASM1-NEXT: 180002018: f940016b     ldr     x11, [x11]
+DISASM1-NEXT: 18000201c: 9000000a     adrp    x10, 0x180002000 <.text+0x1000>
+DISASM1-NEXT: 180002020: 9100f14a     add     x10, x10, #0x3c
+DISASM1-NEXT: 180002024: 17fffff7     b       0x180002000 <.text+0x1000>
+DISASM1-NEXT: 180002028: d000000b     adrp    x11, 0x180004000
+DISASM1-NEXT: 18000202c: f940056b     ldr     x11, [x11, #0x8]
+DISASM1-NEXT: 180002030: d0ffffea     adrp    x10, 0x180000000
+DISASM1-NEXT: 180002034: 9100014a     add     x10, x10, #0x0
+DISASM1-NEXT: 180002038: 17fffff2     b       0x180002000 <.text+0x1000>
+DISASM1-NEXT: 18000203c: 52800060     mov     w0, #0x3                // =3
+DISASM1-NEXT: 180002040: d65f03c0     ret
+DISASM1-NEXT:                 ...
+DISASM1-NEXT: 180003000: ff 25 fa 0f 00 00            jmpq    *0xffa(%rip)            # 0x180004000
+
+RUN: llvm-readobj --coff-imports test1.dll | FileCheck -check-prefix=IMPORTS1 %s
+IMPORTS1:      Import {
+IMPORTS1-NEXT:   Name: test.dll
+IMPORTS1-NEXT:   ImportLookupTableRVA: 0x5360
+IMPORTS1-NEXT:   ImportAddressTableRVA: 0x4000
+IMPORTS1-NEXT:   Symbol: func1 (0)
+IMPORTS1-NEXT:   Symbol: func2 (0)
+IMPORTS1-NEXT: }
+IMPORTS1-NEXT: HybridObject {
+IMPORTS1:        Import {
+IMPORTS1-NEXT:     Name: test.dll
+IMPORTS1-NEXT:     ImportLookupTableRVA: 0x5360
+IMPORTS1-NEXT:     ImportAddressTableRVA: 0x4000
+IMPORTS1-NEXT:     Symbol: func1 (0)
+IMPORTS1-NEXT:     Symbol: func2 (0)
+IMPORTS1-NEXT:   }
+IMPORTS1-NEXT: }
+
+RUN: llvm-readobj --hex-dump=.test test1.dll | FileCheck -check-prefix=TEST1 %s
+TEST1:      0x180009000 00600000 00400000 00300000 08200000
+TEST1-NEXT: 0x180009010 08600000 08400000
+
+RUN: llvm-readobj --hex-dump=.testa test1.dll | FileCheck -check-prefix=TEST1A %s
+TEST1A: 0x18000a000 00400000 08400000 00100000
+
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:test2.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          stubs.obj test2-arm64ec.obj test2-arm64.obj test-arm64ec.lib test-arm64.lib
+
+RUN: llvm-readobj --coff-imports test2.dll | FileCheck -check-prefix=IMPORTS2 %s
+IMPORTS2:      Import {
+IMPORTS2-NEXT:   Name: test.dll
+IMPORTS2-NEXT:   ImportLookupTableRVA: 0x3350
+IMPORTS2-NEXT:   ImportAddressTableRVA: 0x2000
+IMPORTS2-NEXT:   Symbol: func3 (0)
+IMPORTS2-NEXT:   Symbol: func1 (0)
+IMPORTS2-NEXT:   Symbol: func2 (0)
+IMPORTS2-NEXT: }
+IMPORTS2-NEXT: HybridObject {
+IMPORTS2:        Import {
+IMPORTS2-NEXT:     Name: test.dll
+IMPORTS2-NEXT:     ImportLookupTableRVA: 0x3358
+IMPORTS2-NEXT:     ImportAddressTableRVA: 0x2008
+IMPORTS2-NEXT:     Symbol: func1 (0)
+IMPORTS2-NEXT:     Symbol: func2 (0)
+IMPORTS2-NEXT:   }
+IMPORTS2-NEXT: }
+
+RUN: llvm-readobj --hex-dump=.test test2.dll | FileCheck -check-prefix=TEST2 %s
+TEST2: 0x180007000 08400000 08200000 10400000 10200000
+
+RUN: llvm-readobj --hex-dump=.testa test2.dll | FileCheck -check-prefix=TEST2A %s
+TEST2A: 0x180008000 08200000 10200000 00200000
+
+RUN: llvm-readobj --hex-dump=.rdata test2.dll | FileCheck -check-prefix=TEST2AUX %s
+TEST2AUX:      0x180004000 00000000 00000000 08100080 01000000
+TEST2AUX-NEXT: 0x180004010 1c100080 01000000 00000000 00000000
+
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:test3.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          stubs.obj test3-arm64ec.obj test3-arm64.obj test-arm64ec.lib test-arm64.lib
+
+RUN: llvm-readobj --coff-imports test3.dll | FileCheck -check-prefix=IMPORTS3 %s
+IMPORTS3:      Import {
+IMPORTS3-NEXT:   Name: test.dll
+IMPORTS3-NEXT:   ImportLookupTableRVA: 0x3350
+IMPORTS3-NEXT:   ImportAddressTableRVA: 0x2000
+IMPORTS3-NEXT:   Symbol: func1 (0)
+IMPORTS3-NEXT:   Symbol: func2 (0)
+IMPORTS3-NEXT: }
+IMPORTS3-NEXT: HybridObject {
+IMPORTS3:        Import {
+IMPORTS3-NEXT:     Name: test.dll
+IMPORTS3-NEXT:     ImportLookupTableRVA: 0x3350
+IMPORTS3-NEXT:     ImportAddressTableRVA: 0x2000
+IMPORTS3-NEXT:     Symbol: func1 (0)
+IMPORTS3-NEXT:     Symbol: func2 (0)
+IMPORTS3-NEXT:     Symbol: func3 (0)
+IMPORTS3-NEXT:   }
+IMPORTS3-NEXT: }
+
+RUN: llvm-readobj --hex-dump=.test test3.dll | FileCheck -check-prefix=TEST3 %s
+TEST3:      0x180007000 00400000 00200000 08400000 08200000
+TEST3-NEXT: 0x180007010 10400000 10200000
+
+RUN: llvm-readobj --hex-dump=.testa test3.dll | FileCheck -check-prefix=TEST3A %s
+TEST3A: 0x180008000 00200000 08200000
+
+RUN: llvm-readobj --hex-dump=.rdata test3.dll | FileCheck -check-prefix=TEST3AUX %s
+TEST3AUX:      0x180004000 08100080 01000000 1c100080 01000000
+TEST3AUX-NEXT: 0x180004010 30100080 01000000 00000000 00000000
+
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:test4.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          stubs.obj test4-arm64ec.obj test4-arm64.obj test-arm64ec.lib test-arm64.lib
+
+RUN: llvm-readobj --coff-imports test4.dll | FileCheck -check-prefix=IMPORTS4 %s
+IMPORTS4:      Import {
+IMPORTS4-NEXT:   Name: test.dll
+IMPORTS4-NEXT:   ImportLookupTableRVA: 0x3350
+IMPORTS4-NEXT:   ImportAddressTableRVA: 0x2000
+IMPORTS4-NEXT:   Symbol: func4 (0)
+IMPORTS4-NEXT:   Symbol: func2 (0)
+IMPORTS4-NEXT:   Symbol: func3 (0)
+IMPORTS4-NEXT: }
+IMPORTS4-NEXT: HybridObject {
+IMPORTS4:        Import {
+IMPORTS4-NEXT:     Name: test.dll
+IMPORTS4-NEXT:     ImportLookupTableRVA: 0x3358
+IMPORTS4-NEXT:     ImportAddressTableRVA: 0x2008
+IMPORTS4-NEXT:     Symbol: func2 (0)
+IMPORTS4-NEXT:     Symbol: func3 (0)
+IMPORTS4-NEXT:     Symbol: func1 (0)
+IMPORTS4-NEXT:   }
+IMPORTS4-NEXT: }
+
+RUN: llvm-readobj --hex-dump=.test test4.dll | FileCheck -check-prefix=TEST4 %s
+TEST4:      0x180007000 18400000 18200000 08400000 08200000
+TEST4-NEXT: 0x180007010 10400000 1020000
+
+RUN: llvm-readobj --hex-dump=.testa test4.dll | FileCheck -check-prefix=TEST4A %s
+TEST4A: 0x180008000 08200000 10200000 00200000
+
+
+RUN: lld-link -machine:arm64x -dll -noentry -out:test5.dll loadconfig-arm64.obj loadconfig-arm64ec.obj \
+RUN:          stubs.obj test5-arm64ec.obj test5-arm64.obj test-arm64ec.lib test-arm64.lib \
+RUN:          test2-arm64ec.lib test2-arm64.lib
+
+RUN: llvm-readobj --coff-imports test5.dll | FileCheck -check-prefix=IMPORTS5 %s
+IMPORTS5:      Import {
+IMPORTS5-NEXT:   Name: test.dll
+IMPORTS5-NEXT:   ImportLookupTableRVA: 0x3368
+IMPORTS5-NEXT:   ImportAddressTableRVA: 0x2000
+IMPORTS5-NEXT:   Symbol: func3 (0)
+IMPORTS5-NEXT:   Symbol: func4 (0)
+IMPORTS5-NEXT: }
+IMPORTS5-NEXT: Import {
+IMPORTS5-NEXT:   Name: test2.dll
+IMPORTS5-NEXT:   ImportLookupTableRVA: 0x3390
+IMPORTS5-NEXT:   ImportAddressTableRVA: 0x2028
+IMPORTS5-NEXT:   Symbol: otherfunc (0)
+IMPORTS5-NEXT: }
+IMPORTS5-NEXT: HybridObject {
+IMPORTS5:        Import {
+IMPORTS5-NEXT:     Name: test.dll
+IMPORTS5-NEXT:     ImportLookupTableRVA: 0x3378
+IMPORTS5-NEXT:     ImportAddressTableRVA: 0x2010
+IMPORTS5-NEXT:     Symbol: func1 (0)
+IMPORTS5-NEXT:     Symbol: func2 (0)
+IMPORTS5-NEXT:   }
+IMPORTS5-NEXT:   Import {
+IMPORTS5-NEXT:     Name: test2.dll
+IMPORTS5-NEXT:     ImportLookupTableRVA: 0x3390
+IMPORTS5-NEXT:     ImportAddressTableRVA: 0x2028
+IMPORTS5-NEXT:     Symbol: otherfunc (0)
+IMPORTS5-NEXT:   }
+IMPORTS5-NEXT: }
+
+RUN: llvm-readobj --hex-dump=.test test5.dll | FileCheck -check-prefix=TEST5 %s
+TEST5:      0x180007000 10400000 10200000 18400000 18200000
+TEST5-NEXT: 0x180007010 28400000 28200000
+
+RUN: llvm-readobj --hex-dump=.testa test5.dll | FileCheck -check-prefix=TEST5A %s
+TEST5A: 0x180008000 00200000 08200000 28200000
+
+
+#--- test1-arm64ec.s
+    .section .test, "r"
+    .rva __imp_func1
+    .rva __imp_aux_func1
+    .rva func1
+    .rva "#func1"
+    .rva __imp_func2
+    .rva __imp_aux_func2
+
+#--- test1-arm64.s
+    .section .testa, "r"
+    .rva __imp_func1
+    .rva __imp_func2
+    .rva func2
+
+#--- test2-arm64ec.s
+    .section .test, "r"
+    .rva __imp_func1
+    .rva __imp_aux_func1
+    .rva __imp_func2
+    .rva __imp_aux_func2
+
+#--- test2-arm64.s
+    .section .testa, "r"
+    .rva __imp_func1
+    .rva __imp_func2
+    .rva __imp_func3
+
+#--- test3-arm64ec.s
+    .section .test, "r"
+    .rva __imp_func1
+    .rva __imp_aux_func1
+    .rva __imp_func2
+    .rva __imp_aux_func2
+    .rva __imp_func3
+    .rva __imp_aux_func3
+
+#--- test3-arm64.s
+    .section .testa, "r"
+    .rva __imp_func1
+    .rva __imp_func2
+
+#--- test4-arm64ec.s
+    .section .test, "r"
+    .rva __imp_func1
+    .rva __imp_aux_func1
+    .rva __imp_func2
+    .rva __imp_aux_func2
+    .rva __imp_func3
+    .rva __imp_aux_func3
+
+#--- test4-arm64.s
+    .section .testa, "r"
+    .rva __imp_func2
+    .rva __imp_func3
+    .rva __imp_func4
+
+#--- test5-arm64ec.s
+    .section .test, "r"
+    .rva __imp_func1
+    .rva __imp_aux_func1
+    .rva __imp_func2
+    .rva __imp_aux_func2
+    .rva __imp_otherfunc
+    .rva __imp_aux_otherfunc
+
+#--- test5-arm64.s
+    .section .testa, "r"
+    .rva __imp_func3
+    .rva __imp_func4
+    .rva __imp_otherfunc
+
+#--- stubs.s
+    .text
+    .globl __icall_helper_arm64ec
+    .p2align 2, 0x0
+__icall_helper_arm64ec:
+    mov w0, #2
+    ret
+
+    .section .cfg, "r"
+    .globl __os_arm64x_dispatch_icall
+    .p2align 2, 0x0
+__os_arm64x_dispatch_icall:
+    .xword 1
+
+    .section .hybmp$x, "yi"
+    .symidx __imp_func1
+    .symidx func1_exit_thunk
+    .word 4
+
+    .section .wowthk$aa,"xr",discard,func1_exit_thunk
+    .globl func1_exit_thunk
+func1_exit_thunk:
+    mov w0, #3
+    ret
+
+#--- test.def
+NAME test.dll
+EXPORTS
+    mydata DATA
+    func1
+    func2
+    func3
+    func4
+
+#--- test2.def
+NAME test2.dll
+EXPORTS
+    otherfunc
diff --git a/lld/test/COFF/arm64x.test b/lld/test/COFF/arm64x.test
new file mode 100644
index 000000000000..001c5e559105
--- /dev/null
+++ b/lld/test/COFF/arm64x.test
@@ -0,0 +1,87 @@
+REQUIRES: aarch64
+RUN: mkdir -p %t.dir && cd %t.dir
+
+RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %S/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
+
+RUN: lld-link -machine:arm64x -out:testz.dll -dll -noentry loadconfig-arm64.obj
+RUN: llvm-readobj --coff-load-config testz.dll | FileCheck -check-prefix=DYNRELOCSZ %s
+
+DYNRELOCSZ:      DynamicRelocations [
+DYNRELOCSZ-NEXT:   Version: 0x1
+DYNRELOCSZ-NEXT:   Arm64X [
+DYNRELOCSZ-NEXT:     Entry [
+DYNRELOCSZ-NEXT:       RVA: 0x7C
+DYNRELOCSZ-NEXT:       Type: VALUE
+DYNRELOCSZ-NEXT:       Size: 0x2
+DYNRELOCSZ-NEXT:       Value: 0x8664
+DYNRELOCSZ-NEXT:     ]
+DYNRELOCSZ-NEXT:     Entry [
+DYNRELOCSZ-NEXT:       RVA: 0x150
+DYNRELOCSZ-NEXT:       Type: VALUE
+DYNRELOCSZ-NEXT:       Size: 0x4
+DYNRELOCSZ-NEXT:       Value: 0x0
+DYNRELOCSZ-NEXT:     ]
+DYNRELOCSZ-NEXT:     Entry [
+DYNRELOCSZ-NEXT:       RVA: 0x154
+DYNRELOCSZ-NEXT:       Type: VALUE
+DYNRELOCSZ-NEXT:       Size: 0x4
+DYNRELOCSZ-NEXT:       Value: 0x0
+DYNRELOCSZ-NEXT:     ]
+DYNRELOCSZ-NEXT:   ]
+DYNRELOCSZ-NEXT: ]
+
+RUN: lld-link -machine:arm64x -out:test.dll -dll -noentry loadconfig-arm64.obj loadconfig-arm64ec.obj
+RUN: llvm-readobj --coff-load-config test.dll | FileCheck -check-prefix=DYNRELOCS %s
+
+DYNRELOCS:      DynamicRelocations [
+DYNRELOCS-NEXT:   Version: 0x1
+DYNRELOCS-NEXT:   Arm64X [
+DYNRELOCS-NEXT:     Entry [
+DYNRELOCS-NEXT:       RVA: 0x7C
+DYNRELOCS-NEXT:       Type: VALUE
+DYNRELOCS-NEXT:       Size: 0x2
+DYNRELOCS-NEXT:       Value: 0x8664
+DYNRELOCS-NEXT:     ]
+DYNRELOCS-NEXT:     Entry [
+DYNRELOCS-NEXT:       RVA: 0x150
+DYNRELOCS-NEXT:       Type: VALUE
+DYNRELOCS-NEXT:       Size: 0x4
+DYNRELOCS-NEXT:       Value: 0x1140
+DYNRELOCS-NEXT:     ]
+DYNRELOCS-NEXT:     Entry [
+DYNRELOCS-NEXT:       RVA: 0x154
+DYNRELOCS-NEXT:       Type: VALUE
+DYNRELOCS-NEXT:       Size: 0x4
+DYNRELOCS-NEXT:       Value: 0x140
+DYNRELOCS-NEXT:     ]
+DYNRELOCS-NEXT:   ]
+DYNRELOCS-NEXT: ]
+
+RUN: llvm-readobj --coff-basereloc test.dll | FileCheck -check-prefix=BASERELOCS %s
+BASERELOCS:      BaseReloc [
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: DIR64
+BASERELOCS-NEXT:     Address: 0x10C8
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: DIR64
+BASERELOCS-NEXT:     Address: 0x1198
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: DIR64
+BASERELOCS-NEXT:     Address: 0x11B0
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: DIR64
+BASERELOCS-NEXT:     Address: 0x11B8
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: DIR64
+BASERELOCS-NEXT:     Address: 0x1208
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT:   Entry {
+BASERELOCS-NEXT:     Type: ABSOLUTE
+BASERELOCS-NEXT:     Address: 0x1000
+BASERELOCS-NEXT:   }
+BASERELOCS-NEXT: ]
diff --git a/lld/test/COFF/pdata-arm64ec.test b/lld/test/COFF/pdata-arm64ec.test
index 7f20c460dc10..fbec797525f7 100644
--- a/lld/test/COFF/pdata-arm64ec.test
+++ b/lld/test/COFF/pdata-arm64ec.test
@@ -6,6 +6,7 @@ Test handlign of hybrid .pdata section on ARM64EC target.
 RUN: llvm-mc -filetype=obj -triple=arm64-windows arm64-func-sym.s -o arm64-func-sym.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows arm64ec-func-sym.s -o arm64ec-func-sym.obj
 RUN: llvm-mc -filetype=obj -triple=x86_64-windows x86_64-func-sym.s -o x86_64-func-sym.obj
+RUN: llvm-mc -filetype=obj -triple=aarch64-windows %S/Inputs/loadconfig-arm64.s -o loadconfig-arm64.obj
 RUN: llvm-mc -filetype=obj -triple=arm64ec-windows %p/Inputs/loadconfig-arm64ec.s -o loadconfig-arm64ec.obj
 
 Only arm64ec code:
@@ -55,11 +56,21 @@ DATA3: 180005000 00100000 11000001 00200000 0e200000
 Mixed arm64x code:
 
 RUN: lld-link -out:test4.dll -machine:arm64x arm64-func-sym.obj arm64ec-func-sym.obj \
-RUN:          x86_64-func-sym.obj loadconfig-arm64ec.obj -dll -noentry
+RUN:          x86_64-func-sym.obj loadconfig-arm64.obj loadconfig-arm64ec.obj -dll -noentry
 
 RUN: llvm-readobj --headers test4.dll | FileCheck -check-prefix=DIR3 %s
-DIR3:      ExceptionTableRVA: 0x6000
-DIR3-NEXT: ExceptionTableSize: 0x10
+DIR3:      ImageOptionalHeader {
+DIR3:        DataDirectory {
+DIR3:          ExceptionTableRVA: 0x6000
+DIR3-NEXT:     ExceptionTableSize: 0x10
+DIR3:        }
+DIR3:      }
+DIR3:      HybridObject {
+DIR3:        ImageOptionalHeader {
+DIR3:          ExceptionTableRVA: 0x6010
+DIR3-NEXT:     ExceptionTableSize: 0xC
+DIR3:        }
+DIR3:      }
 
 RUN: llvm-objdump -s --section=.pdata test4.dll | FileCheck -check-prefix=DATA4 %s
 DATA4: 180006000 00100000 11000001 00200000 11000001  ......... ......
@@ -74,12 +85,12 @@ RUN: llvm-readobj --headers test5.dll | FileCheck -check-prefix=DIR2 %s
 RUN: llvm-objdump -s --section=.pdata test5.dll | FileCheck -check-prefix=DATA3 %s
 
 RUN: lld-link -out:test6.dll -machine:arm64x arm64ec-func-sym.obj x86_64-func-sym.obj \
-RUN:          arm64-func-sym.obj loadconfig-arm64ec.obj -dll -noentry
+RUN:          arm64-func-sym.obj loadconfig-arm64.obj loadconfig-arm64ec.obj -dll -noentry
 RUN: llvm-readobj --headers test6.dll | FileCheck -check-prefix=DIR3 %s
 RUN: llvm-objdump -s --section=.pdata test6.dll | FileCheck -check-prefix=DATA4 %s
 
 RUN: lld-link -out:test7.dll -machine:arm64x x86_64-func-sym.obj arm64ec-func-sym.obj \
-RUN:          arm64-func-sym.obj loadconfig-arm64ec.obj -dll -noentry
+RUN:          arm64-func-sym.obj loadconfig-arm64.obj loadconfig-arm64ec.obj -dll -noentry
 RUN: llvm-readobj --headers test7.dll | FileCheck -check-prefix=DIR3 %s
 RUN: llvm-objdump -s --section=.pdata test7.dll | FileCheck -check-prefix=DATA4 %s
 
-- 
2.25.1

